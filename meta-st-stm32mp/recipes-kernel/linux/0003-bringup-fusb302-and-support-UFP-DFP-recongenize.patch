From 3c741ba23c994cf391391fc5b56c476e9acd056d Mon Sep 17 00:00:00 2001
From: Tao Tang <15642339119@163.com>
Date: Sat, 1 Jul 2023 21:58:39 +0800
Subject: [PATCH] bringup fusb302 and support UFP/DFP recongenize

Signed-off-by: Tao Tang <15642339119@163.com>
---
 arch/arm/boot/dts/stm32mp157d-robot.dtsi |   97 +-
 drivers/usb/typec/tcpm/fusb302.c         | 4690 +++++++++++++++-------
 drivers/usb/typec/tcpm/fusb302.h         |  554 +++
 3 files changed, 3793 insertions(+), 1548 deletions(-)
 create mode 100644 drivers/usb/typec/tcpm/fusb302.h

diff --git a/arch/arm/boot/dts/stm32mp157d-robot.dtsi b/arch/arm/boot/dts/stm32mp157d-robot.dtsi
index 7bf87c3c8..3d87f8858 100644
--- a/arch/arm/boot/dts/stm32mp157d-robot.dtsi
+++ b/arch/arm/boot/dts/stm32mp157d-robot.dtsi
@@ -8,7 +8,7 @@
 #include "stm32mp15-m4-srm-pinctrl.dtsi"
 #include <dt-bindings/gpio/gpio.h>
 #include <dt-bindings/mfd/st,stpmic1.h>
-
+#include <dt-bindings/usb/pd.h>
 / {
 	memory@c0000000 {
 		device_type = "memory";
@@ -96,15 +96,6 @@ vddcore: buck1 {
         	regulator-boot-on;
 	};
 
-   	vdd_usb: regulator-vdd-usb {
-        	compatible = "regulator-fixed";
-        	regulator-name = "vdd_usb";
-        	regulator-min-microvolt = <3300000>;
-       		regulator-max-microvolt = <3300000>;
-        	regulator-always-on;
-        	regulator-boot-on;
-    	};
-
     	vdd: regulator-vdd {
 		compatible = "regulator-fixed";
 		regulator-name = "vdd";
@@ -212,6 +203,17 @@ panel-timing-7 {
 			vback-porch = <23>;
 		};
 	};
+
+	usb_phy_tuning: usb-phy-tuning {
+		st,hs-dc-level = <2>;
+		st,fs-rftime-tuning;
+		st,hs-rftime-reduction;
+		st,hs-current-trim = <15>;
+		st,hs-impedance-trim = <1>;
+		st,squelch-level = <3>;
+		st,hs-rx-offset = <2>;
+		st,no-lsfs-sc;
+	};
 };
 
 &ltdc {
@@ -259,10 +261,19 @@ &hash1 {
 	status = "okay";
 };
 
-&i2c4 {
+&pinctrl {
+    fsusb302_pins_b: stusb1600-0 {
+        pins {
+            pinmux = <STM32_PINMUX('D', 7, ANALOG)>;
+            bias-pull-up;
+        };
+    };
+};
+
+&i2c5 {
 	pinctrl-names = "default", "sleep";
-	pinctrl-0 = <&i2c4_pins_a>;
-	pinctrl-1 = <&i2c4_sleep_pins_a>;
+	pinctrl-0 = <&i2c5_pins_a>;
+	pinctrl-1 = <&i2c5_sleep_pins_a>;
 	i2c-scl-rising-time-ns = <185>;
 	i2c-scl-falling-time-ns = <20>;
 	clock-frequency = <400000>;
@@ -270,6 +281,34 @@ &i2c4 {
 	/* spare dmas for other usage */
 	/delete-property/dmas;
 	/delete-property/dma-names;
+
+    	typec: fusb302@22 {
+		compatible = "fcs,fusb302","fairchild,fusb302";
+		reg = <0x22>;
+		// pinctrl-names = "default";
+		// pinctrl-0 = <&fsusb302_pins_b>;
+		int-n-gpios = <&gpiod 7 GPIO_ACTIVE_HIGH>;
+		vbus-5v-gpios = <&gpiof 5 GPIO_ACTIVE_HIGH>;
+		status = "okay";
+		connector {
+			compatible = "usb-c-connector";
+			label = "USB-C";
+			power-role = "dual";
+			power-opmode = "default";
+			try-power-role = "sink";
+			source-pdos = <PDO_FIXED(5000, 3000, PDO_FIXED_USB_COMM)>;
+			sink-pdos = <PDO_FIXED(5000, 3000, PDO_FIXED_USB_COMM)
+				PDO_VAR(3000, 12000, 3000)
+				PDO_PPS_APDO(3000, 11000, 3000)>;
+			op-sink-microwatt = <10000000>;
+			port {
+				con_usbotg_hs_ep: endpoint {
+					remote-endpoint = <&usbotg_hs_ep>;
+				};
+			};
+
+		};
+    	};
 };
 
 &ipcc {
@@ -294,7 +333,7 @@ &m4_rproc {
 
 &pwr_regulators {
 	vdd-supply = <&vdd>;
-	vdd_3v3_usbfs-supply = <&vdd_usb>;
+	vdd_3v3_usbfs-supply = <&v3v3>;
 };
 
 &rng1 {
@@ -357,16 +396,36 @@ &uart4 {
 	status = "okay";
 };
 
-// &usbotg_hs {
-// 	vbus-supply = <&vbus_otg>;
-// };
+&usbphyc {
+	status = "okay";
+};
 
 &usbphyc_port0 {
-	phy-supply = <&vdd_usb>;
+	phy-supply = <&v3v3>;
+	st,phy-tuning = <&usb_phy_tuning>;
 };
 
 &usbphyc_port1 {
-	phy-supply = <&vdd_usb>;
+	phy-supply = <&v3v3>;
+	st,phy-tuning = <&usb_phy_tuning>;
+};
+
+&usbh_ehci {
+	phys = <&usbphyc_port0>;
+	status = "okay";
+};
+
+&usbotg_hs {
+	phys = <&usbphyc_port1 0>;
+	phy-names = "usb2-phy";
+	usb-role-switch;
+	status = "okay";
+
+	port {
+		usbotg_hs_ep: endpoint {
+			remote-endpoint = <&con_usbotg_hs_ep>;
+		};
+	};
 };
 
 &ethernet0 {
diff --git a/drivers/usb/typec/tcpm/fusb302.c b/drivers/usb/typec/tcpm/fusb302.c
index 99562cc65..e44e13723 100644
--- a/drivers/usb/typec/tcpm/fusb302.c
+++ b/drivers/usb/typec/tcpm/fusb302.c
@@ -1,1842 +1,3474 @@
-// SPDX-License-Identifier: GPL-2.0+
 /*
- * Copyright 2016-2017 Google, Inc
+ * Copyright (c) 2016, Fuzhou Rockchip Electronics Co., Ltd
+ * Author: Zain Wang <zain.wang@rock-chips.com>
  *
- * Fairchild FUSB302 Type-C Chip Driver
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * Some ideas are from chrome ec and fairchild GPL fusb302 driver.
  */
 
-#include <linux/debugfs.h>
 #include <linux/delay.h>
-#include <linux/errno.h>
 #include <linux/extcon.h>
-#include <linux/gpio/consumer.h>
-#include <linux/i2c.h>
+#include <linux/gpio.h>
 #include <linux/interrupt.h>
-#include <linux/kernel.h>
 #include <linux/module.h>
-#include <linux/mutex.h>
-#include <linux/of_device.h>
-#include <linux/pinctrl/consumer.h>
-#include <linux/proc_fs.h>
-#include <linux/regulator/consumer.h>
-#include <linux/sched/clock.h>
-#include <linux/seq_file.h>
-#include <linux/slab.h>
-#include <linux/spinlock.h>
-#include <linux/string.h>
-#include <linux/types.h>
-#include <linux/usb.h>
-#include <linux/usb/typec.h>
-#include <linux/usb/tcpm.h>
-#include <linux/usb/pd.h>
+#include <linux/of_gpio.h>
+#include <linux/regmap.h>
+#include <linux/power_supply.h>
+#include <linux/extcon-provider.h>
+#include <linux/usb/role.h>
+
+#include <linux/kernel.h>
 #include <linux/workqueue.h>
 
-#include "fusb302_reg.h"
 
-/*
- * When the device is SNK, BC_LVL interrupt is used to monitor cc pins
- * for the current capability offered by the SRC. As FUSB302 chip fires
- * the BC_LVL interrupt on PD signalings, cc lvl should be handled after
- * a delay to avoid measuring on PD activities. The delay is slightly
- * longer than PD_T_PD_DEBPUNCE (10-20ms).
- */
-#define T_BC_LVL_DEBOUNCE_DELAY_MS 30
+#include "fusb302.h"
 
-enum toggling_mode {
-	TOGGLING_MODE_OFF,
-	TOGGLING_MODE_DRP,
-	TOGGLING_MODE_SNK,
-	TOGGLING_MODE_SRC,
-};
+#define FUSB302_MAX_REG		(FUSB_REG_FIFO + 50)
+#define FUSB_MS_TO_NS(x)	((s64)x * 1000 * 1000)
 
-enum src_current_status {
-	SRC_CURRENT_DEFAULT,
-	SRC_CURRENT_MEDIUM,
-	SRC_CURRENT_HIGH,
-};
+#define TYPEC_CC_VOLT_OPEN	0
+#define TYPEC_CC_VOLT_RA	1
+#define TYPEC_CC_VOLT_RD	2
+#define TYPEC_CC_VOLT_RP	3
 
-static const u8 ra_mda_value[] = {
-	[SRC_CURRENT_DEFAULT] = 4,	/* 210mV */
-	[SRC_CURRENT_MEDIUM] = 9,	/* 420mV */
-	[SRC_CURRENT_HIGH] = 18,	/* 798mV */
-};
+#define EVENT_CC		BIT(0)
+#define EVENT_RX		BIT(1)
+#define EVENT_TX		BIT(2)
+#define EVENT_REC_RESET		BIT(3)
+#define EVENT_WORK_CONTINUE	BIT(5)
+#define EVENT_TIMER_MUX		BIT(6)
+#define EVENT_TIMER_STATE	BIT(7)
+#define EVENT_DELAY_CC		BIT(8)
+#define FLAG_EVENT		(EVENT_RX | EVENT_TIMER_MUX | \
+				 EVENT_TIMER_STATE)
 
-static const u8 rd_mda_value[] = {
-	[SRC_CURRENT_DEFAULT] = 38,	/* 1638mV */
-	[SRC_CURRENT_MEDIUM] = 38,	/* 1638mV */
-	[SRC_CURRENT_HIGH] = 61,	/* 2604mV */
-};
+#define PACKET_IS_CONTROL_MSG(header, type) \
+		(PD_HEADER_CNT(header) == 0 && \
+		 PD_HEADER_TYPE(header) == type)
 
-#define LOG_BUFFER_ENTRIES	1024
-#define LOG_BUFFER_ENTRY_SIZE	128
-
-struct fusb302_chip {
-	struct device *dev;
-	struct i2c_client *i2c_client;
-	struct tcpm_port *tcpm_port;
-	struct tcpc_dev tcpc_dev;
-
-	struct regulator *vbus;
-
-	spinlock_t irq_lock;
-	struct work_struct irq_work;
-	bool irq_suspended;
-	bool irq_while_suspended;
-	struct gpio_desc *gpio_int_n;
-	int gpio_int_n_irq;
-	struct extcon_dev *extcon;
-
-	struct workqueue_struct *wq;
-	struct delayed_work bc_lvl_handler;
-
-	/* lock for sharing chip states */
-	struct mutex lock;
-
-	/* chip status */
-	enum toggling_mode toggling_mode;
-	enum src_current_status src_current_status;
-	bool intr_togdone;
-	bool intr_bc_lvl;
-	bool intr_comp_chng;
-
-	/* port status */
-	bool vconn_on;
-	bool vbus_on;
-	bool charge_on;
-	bool vbus_present;
-	enum typec_cc_polarity cc_polarity;
-	enum typec_cc_status cc1;
-	enum typec_cc_status cc2;
-	u32 snk_pdo[PDO_MAX_OBJECTS];
-
-#ifdef CONFIG_DEBUG_FS
-	struct dentry *dentry;
-	/* lock for log buffer access */
-	struct mutex logbuffer_lock;
-	int logbuffer_head;
-	int logbuffer_tail;
-	u8 *logbuffer[LOG_BUFFER_ENTRIES];
-#endif
-};
+#define PACKET_IS_DATA_MSG(header, type) \
+		(PD_HEADER_CNT(header) != 0 && \
+		 PD_HEADER_TYPE(header) == type)
 
 /*
- * Logging
+ * DisplayPort modes capabilities
+ * -------------------------------
+ * <31:24> : Reserved (always 0).
+ * <23:16> : UFP_D pin assignment supported
+ * <15:8>  : DFP_D pin assignment supported
+ * <7>     : USB 2.0 signaling (0b=yes, 1b=no)
+ * <6>     : Plug | Receptacle (0b == plug, 1b == receptacle)
+ * <5:2>   : xxx1: Supports DPv1.3, xx1x Supports USB Gen 2 signaling
+ *	     Other bits are reserved.
+ * <1:0>   : signal direction ( 00b=rsv, 01b=sink, 10b=src 11b=both )
  */
+#define PD_DP_PIN_CAPS(x)	((((x) >> 6) & 0x1) ? (((x) >> 16) & 0x3f) \
+				 : (((x) >> 8) & 0x3f))
+#define PD_DP_SIGNAL_GEN2(x)	(((x) >> 3) & 0x1)
+
+#define MODE_DP_PIN_A		BIT(0)
+#define MODE_DP_PIN_B		BIT(1)
+#define MODE_DP_PIN_C		BIT(2)
+#define MODE_DP_PIN_D		BIT(3)
+#define MODE_DP_PIN_E		BIT(4)
+#define MODE_DP_PIN_F		BIT(5)
+
+/* Pin configs B/D/F support multi-function */
+#define MODE_DP_PIN_MF_MASK	(MODE_DP_PIN_B | MODE_DP_PIN_D | MODE_DP_PIN_F)
+/* Pin configs A/B support BR2 signaling levels */
+#define MODE_DP_PIN_BR2_MASK	(MODE_DP_PIN_A | MODE_DP_PIN_B)
+/* Pin configs C/D/E/F support DP signaling levels */
+#define MODE_DP_PIN_DP_MASK	(MODE_DP_PIN_C | MODE_DP_PIN_D | \
+				 MODE_DP_PIN_E | MODE_DP_PIN_F)
 
-#ifdef CONFIG_DEBUG_FS
-static bool fusb302_log_full(struct fusb302_chip *chip)
-{
-	return chip->logbuffer_tail ==
-		(chip->logbuffer_head + 1) % LOG_BUFFER_ENTRIES;
-}
-
-__printf(2, 0)
-static void _fusb302_log(struct fusb302_chip *chip, const char *fmt,
-			 va_list args)
-{
-	char tmpbuffer[LOG_BUFFER_ENTRY_SIZE];
-	u64 ts_nsec = local_clock();
-	unsigned long rem_nsec;
-
-	if (!chip->logbuffer[chip->logbuffer_head]) {
-		chip->logbuffer[chip->logbuffer_head] =
-				kzalloc(LOG_BUFFER_ENTRY_SIZE, GFP_KERNEL);
-		if (!chip->logbuffer[chip->logbuffer_head])
-			return;
-	}
-
-	vsnprintf(tmpbuffer, sizeof(tmpbuffer), fmt, args);
-
-	mutex_lock(&chip->logbuffer_lock);
-
-	if (fusb302_log_full(chip)) {
-		chip->logbuffer_head = max(chip->logbuffer_head - 1, 0);
-		strlcpy(tmpbuffer, "overflow", sizeof(tmpbuffer));
-	}
+/*
+ * DisplayPort Status VDO
+ * ----------------------
+ * <31:9> : Reserved (always 0).
+ * <8>    : IRQ_HPD : 1 == irq arrived since last message otherwise 0.
+ * <7>    : HPD state : 0 = HPD_LOW, 1 == HPD_HIGH
+ * <6>    : Exit DP Alt mode: 0 == maintain, 1 == exit
+ * <5>    : USB config : 0 == maintain current, 1 == switch to USB from DP
+ * <4>    : Multi-function preference : 0 == no pref, 1 == MF preferred.
+ * <3>    : enabled : is DPout on/off.
+ * <2>    : power low : 0 == normal or LPM disabled, 1 == DP disabled for LPM
+ * <1:0>  : connect status : 00b ==  no (DFP|UFP)_D is connected or disabled.
+ *	    01b == DFP_D connected, 10b == UFP_D connected, 11b == both.
+ */
+#define PD_VDO_DPSTS_HPD_IRQ(x)	(((x) >> 8) & 0x1)
+#define PD_VDO_DPSTS_HPD_LVL(x)	(((x) >> 7) & 0x1)
+#define PD_VDO_DPSTS_MF_PREF(x)	(((x) >> 4) & 0x1)
 
-	if (chip->logbuffer_head < 0 ||
-	    chip->logbuffer_head >= LOG_BUFFER_ENTRIES) {
-		dev_warn(chip->dev,
-			 "Bad log buffer index %d\n", chip->logbuffer_head);
-		goto abort;
-	}
+#define EXTCON_USB_VBUS_EN    3
 
-	if (!chip->logbuffer[chip->logbuffer_head]) {
-		dev_warn(chip->dev,
-			 "Log buffer index %d is NULL\n", chip->logbuffer_head);
-		goto abort;
-	}
+static struct delayed_work my_delayed_work;
+static struct workqueue_struct *my_workqueue;
 
-	rem_nsec = do_div(ts_nsec, 1000000000);
-	scnprintf(chip->logbuffer[chip->logbuffer_head],
-		  LOG_BUFFER_ENTRY_SIZE, "[%5lu.%06lu] %s",
-		  (unsigned long)ts_nsec, rem_nsec / 1000,
-		  tmpbuffer);
-	chip->logbuffer_head = (chip->logbuffer_head + 1) % LOG_BUFFER_ENTRIES;
 
-abort:
-	mutex_unlock(&chip->logbuffer_lock);
-}
+static u8 fusb30x_port_used;
+static struct fusb30x_chip *fusb30x_port_info[256];
 
-__printf(2, 3)
-static void fusb302_log(struct fusb302_chip *chip, const char *fmt, ...)
+static bool is_write_reg(struct device *dev, unsigned int reg)
 {
-	va_list args;
-
-	va_start(args, fmt);
-	_fusb302_log(chip, fmt, args);
-	va_end(args);
+	if (reg >= FUSB_REG_FIFO)
+		return true;
+	else
+		return ((reg < (FUSB_REG_CONTROL4 + 1)) && (reg > 0x01)) ?
+			true : false;
 }
 
-static int fusb302_debug_show(struct seq_file *s, void *v)
+static bool is_volatile_reg(struct device *dev, unsigned int reg)
 {
-	struct fusb302_chip *chip = (struct fusb302_chip *)s->private;
-	int tail;
+	if (reg > FUSB_REG_CONTROL4)
+		return true;
 
-	mutex_lock(&chip->logbuffer_lock);
-	tail = chip->logbuffer_tail;
-	while (tail != chip->logbuffer_head) {
-		seq_printf(s, "%s\n", chip->logbuffer[tail]);
-		tail = (tail + 1) % LOG_BUFFER_ENTRIES;
+	switch (reg) {
+	case FUSB_REG_CONTROL0:
+	case FUSB_REG_CONTROL1:
+	case FUSB_REG_CONTROL3:
+	case FUSB_REG_RESET:
+		return true;
 	}
-	if (!seq_has_overflowed(s))
-		chip->logbuffer_tail = tail;
-	mutex_unlock(&chip->logbuffer_lock);
-
-	return 0;
+	return false;
 }
-DEFINE_SHOW_ATTRIBUTE(fusb302_debug);
-
-static void fusb302_debugfs_init(struct fusb302_chip *chip)
-{
-	char name[NAME_MAX];
 
-	mutex_init(&chip->logbuffer_lock);
-	snprintf(name, NAME_MAX, "fusb302-%s", dev_name(chip->dev));
-	chip->dentry = debugfs_create_file(name, S_IFREG | 0444, usb_debug_root,
-					   chip, &fusb302_debug_fops);
-}
+struct regmap_config fusb302_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+	.writeable_reg = is_write_reg,
+	.volatile_reg = is_volatile_reg,
+	.max_register = FUSB302_MAX_REG,
+	.cache_type = REGCACHE_RBTREE,
+};
 
-static void fusb302_debugfs_exit(struct fusb302_chip *chip)
+static void dump_notify_info(struct fusb30x_chip *chip)
 {
-	debugfs_remove(chip->dentry);
+	dev_dbg(chip->dev, "port        %d\n", chip->port_num);
+	dev_dbg(chip->dev, "orientation %d\n", chip->notify.orientation);
+	dev_dbg(chip->dev, "power_role  %d\n", chip->notify.power_role);
+	dev_dbg(chip->dev, "data_role   %d\n", chip->notify.data_role);
+	dev_dbg(chip->dev, "cc          %d\n", chip->notify.is_cc_connected);
+	dev_dbg(chip->dev, "pd          %d\n", chip->notify.is_pd_connected);
+	dev_dbg(chip->dev, "enter_mode  %d\n", chip->notify.is_enter_mode);
+	dev_dbg(chip->dev, "pin support %d\n",
+		chip->notify.pin_assignment_support);
+	dev_dbg(chip->dev, "pin def     %d\n", chip->notify.pin_assignment_def);
+	dev_dbg(chip->dev, "attention   %d\n", chip->notify.attention);
 }
 
-#else
-
-static void fusb302_log(const struct fusb302_chip *chip,
-			const char *fmt, ...) { }
-static void fusb302_debugfs_init(const struct fusb302_chip *chip) { }
-static void fusb302_debugfs_exit(const struct fusb302_chip *chip) { }
-
-#endif
+static const unsigned int fusb302_cable[] = {
+	EXTCON_USB,
+	EXTCON_USB_HOST,
+	EXTCON_USB_VBUS_EN,
+	EXTCON_CHG_USB_SDP,
+	EXTCON_CHG_USB_CDP,
+	EXTCON_CHG_USB_DCP,
+	EXTCON_CHG_USB_SLOW,
+	EXTCON_CHG_USB_FAST,
+	EXTCON_DISP_DP,
+	EXTCON_NONE,
+};
 
-static int fusb302_i2c_write(struct fusb302_chip *chip,
-			     u8 address, u8 data)
+static void fusb_set_pos_power(struct fusb30x_chip *chip, int max_vol,
+			       int max_cur)
 {
-	int ret = 0;
-
-	ret = i2c_smbus_write_byte_data(chip->i2c_client, address, data);
-	if (ret < 0)
-		fusb302_log(chip, "cannot write 0x%02x to 0x%02x, ret=%d",
-			    data, address, ret);
-
-	return ret;
+	int i;
+	int pos_find;
+	int tmp;
+
+	pos_find = 0;
+	for (i = PD_HEADER_CNT(chip->rec_head) - 1; i >= 0; i--) {
+		switch (CAP_POWER_TYPE(chip->rec_load[i])) {
+		case 0:
+			/* Fixed Supply */
+			if ((CAP_FPDO_VOLTAGE(chip->rec_load[i]) * 50) <=
+			    max_vol &&
+			    (CAP_FPDO_CURRENT(chip->rec_load[i]) * 10) <=
+			    max_cur) {
+				chip->pos_power = i + 1;
+				tmp = CAP_FPDO_VOLTAGE(chip->rec_load[i]);
+				chip->pd_output_vol = tmp * 50;
+				tmp = CAP_FPDO_CURRENT(chip->rec_load[i]);
+				chip->pd_output_cur = tmp * 10;
+				pos_find = 1;
+			}
+			break;
+		case 1:
+			/* Battery */
+			if ((CAP_VPDO_VOLTAGE(chip->rec_load[i]) * 50) <=
+			    max_vol &&
+			    (CAP_VPDO_CURRENT(chip->rec_load[i]) * 10) <=
+			    max_cur) {
+				chip->pos_power = i + 1;
+				tmp = CAP_VPDO_VOLTAGE(chip->rec_load[i]);
+				chip->pd_output_vol = tmp * 50;
+				tmp = CAP_VPDO_CURRENT(chip->rec_load[i]);
+				chip->pd_output_cur = tmp * 10;
+				pos_find = 1;
+			}
+			break;
+		default:
+			/* not meet battery caps */
+			break;
+		}
+		if (pos_find)
+			break;
+	}
 }
 
-static int fusb302_i2c_block_write(struct fusb302_chip *chip, u8 address,
-				   u8 length, const u8 *data)
+static int fusb302_set_pos_power_by_charge_ic(struct fusb30x_chip *chip)
 {
-	int ret = 0;
-
-	if (length <= 0)
-		return ret;
+	struct power_supply *psy = NULL;
+	union power_supply_propval val;
+	enum power_supply_property psp;
+	int max_vol, max_cur;
 
-	ret = i2c_smbus_write_i2c_block_data(chip->i2c_client, address,
-					     length, data);
-	if (ret < 0)
-		fusb302_log(chip, "cannot block write 0x%02x, len=%d, ret=%d",
-			    address, length, ret);
+	max_vol = 0;
+	max_cur = 0;
+	psy = power_supply_get_by_phandle(chip->dev->of_node, "charge-dev");
+	if (!psy || IS_ERR(psy))
+		return -1;
 
-	return ret;
-}
+	psp = POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT_MAX;
+	if (power_supply_get_property(psy, psp, &val) == 0)
+		max_vol = val.intval / 1000;
 
-static int fusb302_i2c_read(struct fusb302_chip *chip,
-			    u8 address, u8 *data)
-{
-	int ret = 0;
+	psp = POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT;
+	if (power_supply_get_property(psy, psp, &val) == 0)
+		max_cur = val.intval / 1000;
 
-	ret = i2c_smbus_read_byte_data(chip->i2c_client, address);
-	*data = (u8)ret;
-	if (ret < 0)
-		fusb302_log(chip, "cannot read %02x, ret=%d", address, ret);
+	if (max_vol > 0 && max_cur > 0)
+		fusb_set_pos_power(chip, max_vol, max_cur);
 
-	return ret;
+	return 0;
 }
 
-static int fusb302_i2c_block_read(struct fusb302_chip *chip, u8 address,
-				  u8 length, u8 *data)
+void fusb_irq_disable(struct fusb30x_chip *chip)
 {
-	int ret = 0;
+	unsigned long irqflags = 0;
 
-	if (length <= 0)
-		return ret;
-
-	ret = i2c_smbus_read_i2c_block_data(chip->i2c_client, address,
-					    length, data);
-	if (ret < 0) {
-		fusb302_log(chip, "cannot block read 0x%02x, len=%d, ret=%d",
-			    address, length, ret);
-		goto done;
-	}
-	if (ret != length) {
-		fusb302_log(chip, "only read %d/%d bytes from 0x%02x",
-			    ret, length, address);
-		ret = -EIO;
+	spin_lock_irqsave(&chip->irq_lock, irqflags);
+	if (chip->enable_irq) {
+		disable_irq_nosync(chip->gpio_int_irq);
+		chip->enable_irq = 0;
+	} else {
+		dev_warn(chip->dev, "irq have already disabled\n");
 	}
-
-done:
-	return ret;
+	spin_unlock_irqrestore(&chip->irq_lock, irqflags);
 }
 
-static int fusb302_i2c_mask_write(struct fusb302_chip *chip, u8 address,
-				  u8 mask, u8 value)
+void fusb_irq_enable(struct fusb30x_chip *chip)
 {
-	int ret = 0;
-	u8 data;
-
-	ret = fusb302_i2c_read(chip, address, &data);
-	if (ret < 0)
-		return ret;
-	data &= ~mask;
-	data |= value;
-	ret = fusb302_i2c_write(chip, address, data);
-	if (ret < 0)
-		return ret;
+	unsigned long irqflags = 0;
 
-	return ret;
+	spin_lock_irqsave(&chip->irq_lock, irqflags);
+	if (!chip->enable_irq) {
+		enable_irq(chip->gpio_int_irq);
+		chip->enable_irq = 1;
+	}
+	spin_unlock_irqrestore(&chip->irq_lock, irqflags);
 }
 
-static int fusb302_i2c_set_bits(struct fusb302_chip *chip, u8 address,
-				u8 set_bits)
+static void platform_fusb_notify(struct fusb30x_chip *chip)
 {
-	return fusb302_i2c_mask_write(chip, address, 0x00, set_bits);
+	bool plugged = false, flip = false, dfp = false, ufp = false,
+	     dp = false, usb_ss = false, hpd = false;
+//	union extcon_property_value property;
+
+	if (chip->notify.is_cc_connected)
+		chip->notify.orientation =
+			(chip->cc_polarity == TYPEC_POLARITY_CC1) ?
+			CC1 : CC2;
+
+	/* avoid notify repeated */
+	if (memcmp(&chip->notify, &chip->notify_cmp,
+		   sizeof(struct notify_info))) {
+		dump_notify_info(chip);
+		chip->notify.attention = false;
+		memcpy(&chip->notify_cmp, &chip->notify,
+		       sizeof(struct notify_info));
+
+		plugged = chip->notify.is_cc_connected ||
+			  chip->notify.is_pd_connected;
+		if (chip->notify.orientation != NONE)
+			flip = (chip->notify.orientation == CC1) ? false : true;
+		dp = chip->notify.is_enter_mode;
+
+		if (dp) {
+			dfp = true;
+			usb_ss = (chip->notify.pin_assignment_def &
+				  MODE_DP_PIN_MF_MASK) ? true : false;
+			hpd = GET_DP_STATUS_HPD(chip->notify.dp_status);
+		} else if (chip->notify.data_role) {
+			dfp = true;
+			usb_ss = true;
+		} else if (plugged) {
+			ufp = true;
+			usb_ss = true;
+		}
+#if 0
+		property.intval = flip;
+		extcon_set_property(chip->extcon, EXTCON_USB,
+				    EXTCON_PROP_USB_TYPEC_POLARITY, property);
+		extcon_set_property(chip->extcon, EXTCON_USB_HOST,
+				    EXTCON_PROP_USB_TYPEC_POLARITY, property);
+		extcon_set_property(chip->extcon, EXTCON_DISP_DP,
+				    EXTCON_PROP_USB_TYPEC_POLARITY, property);
+
+		property.intval = usb_ss;
+		extcon_set_property(chip->extcon, EXTCON_USB,
+				    EXTCON_PROP_USB_SS, property);
+		extcon_set_property(chip->extcon, EXTCON_USB_HOST,
+				    EXTCON_PROP_USB_SS, property);
+		extcon_set_property(chip->extcon, EXTCON_DISP_DP,
+				    EXTCON_PROP_USB_SS, property);
+		extcon_set_state(chip->extcon, EXTCON_USB, ufp);
+		extcon_set_state(chip->extcon, EXTCON_USB_HOST, dfp);
+		extcon_set_state(chip->extcon, EXTCON_DISP_DP, dp && hpd);
+		extcon_sync(chip->extcon, EXTCON_USB);
+		extcon_sync(chip->extcon, EXTCON_USB_HOST);
+		extcon_sync(chip->extcon, EXTCON_DISP_DP);
+		if (chip->notify.power_role == POWER_ROLE_SINK &&
+		    chip->notify.is_pd_connected &&
+		    chip->pd_output_vol > 0 && chip->pd_output_cur > 0) {
+			extcon_set_state(chip->extcon, EXTCON_CHG_USB_FAST, true);
+			property.intval =
+				(chip->pd_output_cur << 15 |
+				 chip->pd_output_vol);
+			extcon_set_property(chip->extcon, EXTCON_CHG_USB_FAST,
+					    EXTCON_PROP_USB_TYPEC_POLARITY,
+					    property);
+			extcon_sync(chip->extcon, EXTCON_CHG_USB_FAST);
+		}
+		else {
+			extcon_set_state(chip->extcon, EXTCON_CHG_USB_FAST, false);
+			extcon_sync(chip->extcon, EXTCON_CHG_USB_FAST);
+		}
+#endif		
+	}
 }
 
-static int fusb302_i2c_clear_bits(struct fusb302_chip *chip, u8 address,
-				  u8 clear_bits)
+static bool platform_get_device_irq_state(struct fusb30x_chip *chip)
 {
-	return fusb302_i2c_mask_write(chip, address, clear_bits, 0x00);
+	return !gpiod_get_value(chip->gpio_int);
 }
 
-static int fusb302_sw_reset(struct fusb302_chip *chip)
+static void fusb_timer_start(struct hrtimer *timer, int ms)
 {
-	int ret = 0;
-
-	ret = fusb302_i2c_write(chip, FUSB_REG_RESET,
-				FUSB_REG_RESET_SW_RESET);
-	if (ret < 0)
-		fusb302_log(chip, "cannot sw reset the chip, ret=%d", ret);
-	else
-		fusb302_log(chip, "sw reset");
+	ktime_t ktime;
 
-	return ret;
+	ktime = ktime_set(0, FUSB_MS_TO_NS(ms));
+	hrtimer_start(timer, ktime, HRTIMER_MODE_REL);
 }
 
-static int fusb302_enable_tx_auto_retries(struct fusb302_chip *chip)
+static void platform_set_vbus_lvl_enable(struct fusb30x_chip *chip, int vbus_5v,
+					 int vbus_other)
 {
-	int ret = 0;
-
-	ret = fusb302_i2c_set_bits(chip, FUSB_REG_CONTROL3,
-				   FUSB_REG_CONTROL3_N_RETRIES_3 |
-				   FUSB_REG_CONTROL3_AUTO_RETRY);
-
-	return ret;
-}
+	bool gpio_vbus_value = false;
 
-/*
- * initialize interrupt on the chip
- * - unmasked interrupt: VBUS_OK
- */
-static int fusb302_init_interrupt(struct fusb302_chip *chip)
-{
-	int ret = 0;
+	gpio_vbus_value = gpiod_get_value(chip->gpio_vbus_5v);
+	if (chip->gpio_vbus_5v) {
+		gpiod_set_raw_value(chip->gpio_vbus_5v, vbus_5v);
+		/* Only set state here, don't sync notifier to PMIC */
+//		extcon_set_state(chip->extcon, EXTCON_USB_VBUS_EN, vbus_5v);
+	} else {
+//		extcon_set_state(chip->extcon, EXTCON_USB_VBUS_EN, vbus_5v);
+//		extcon_sync(chip->extcon, EXTCON_USB_VBUS_EN);
+//		dev_info(chip->dev, "fusb302 send extcon to %s vbus 5v\n", vbus_5v ? "enable" : "disable");
+	}
 
-	ret = fusb302_i2c_write(chip, FUSB_REG_MASK,
-				0xFF & ~FUSB_REG_MASK_VBUSOK);
-	if (ret < 0)
-		return ret;
-	ret = fusb302_i2c_write(chip, FUSB_REG_MASKA, 0xFF);
-	if (ret < 0)
-		return ret;
-	ret = fusb302_i2c_write(chip, FUSB_REG_MASKB, 0xFF);
-	if (ret < 0)
-		return ret;
-	ret = fusb302_i2c_clear_bits(chip, FUSB_REG_CONTROL0,
-				     FUSB_REG_CONTROL0_INT_MASK);
-	if (ret < 0)
-		return ret;
+	if (chip->gpio_vbus_other)
+		gpiod_set_raw_value(chip->gpio_vbus_5v, vbus_other);
 
-	return ret;
+	if (chip->gpio_discharge && !vbus_5v && gpio_vbus_value) {
+		gpiod_set_value(chip->gpio_discharge, 1);
+		msleep(20);
+		gpiod_set_value(chip->gpio_discharge, 0);
+	}
 }
 
-static int fusb302_set_power_mode(struct fusb302_chip *chip, u8 power_mode)
+static void set_state(struct fusb30x_chip *chip, enum connection_state state)
 {
-	int ret = 0;
-
-	ret = fusb302_i2c_write(chip, FUSB_REG_POWER, power_mode);
-
-	return ret;
+	dev_dbg(chip->dev, "port %d, state %d\n", chip->port_num, state);
+	if (!state)
+		dev_info(chip->dev, "PD disabled\n");
+	chip->conn_state = state;
+	chip->sub_state = 0;
+	chip->val_tmp = 0;
+	chip->work_continue |= EVENT_WORK_CONTINUE;
 }
 
-static int tcpm_init(struct tcpc_dev *dev)
+static int tcpm_get_message(struct fusb30x_chip *chip)
 {
-	struct fusb302_chip *chip = container_of(dev, struct fusb302_chip,
-						 tcpc_dev);
-	int ret = 0;
-	u8 data;
-
-	ret = fusb302_sw_reset(chip);
-	if (ret < 0)
-		return ret;
-	ret = fusb302_enable_tx_auto_retries(chip);
-	if (ret < 0)
-		return ret;
-	ret = fusb302_init_interrupt(chip);
-	if (ret < 0)
-		return ret;
-	ret = fusb302_set_power_mode(chip, FUSB_REG_POWER_PWR_ALL);
-	if (ret < 0)
-		return ret;
-	ret = fusb302_i2c_read(chip, FUSB_REG_STATUS0, &data);
-	if (ret < 0)
-		return ret;
-	chip->vbus_present = !!(data & FUSB_REG_STATUS0_VBUSOK);
-	ret = fusb302_i2c_read(chip, FUSB_REG_DEVICE_ID, &data);
-	if (ret < 0)
-		return ret;
-	fusb302_log(chip, "fusb302 device ID: 0x%02x", data);
+	u8 buf[32];
+	int len;
 
-	return ret;
-}
+	do {
+		regmap_raw_read(chip->regmap, FUSB_REG_FIFO, buf, 3);
+		chip->rec_head = (buf[1] & 0xff) | ((buf[2] << 8) & 0xff00);
 
-static int tcpm_get_vbus(struct tcpc_dev *dev)
-{
-	struct fusb302_chip *chip = container_of(dev, struct fusb302_chip,
-						 tcpc_dev);
-	int ret = 0;
+		len = PD_HEADER_CNT(chip->rec_head) << 2;
+		regmap_raw_read(chip->regmap, FUSB_REG_FIFO, buf, len + 4);
+	/* ignore good_crc message */
+	} while (PACKET_IS_CONTROL_MSG(chip->rec_head, CMT_GOODCRC));
 
-	mutex_lock(&chip->lock);
-	ret = chip->vbus_present ? 1 : 0;
-	mutex_unlock(&chip->lock);
+	memcpy(chip->rec_load, buf, len);
 
-	return ret;
+	return 0;
 }
 
-static int tcpm_get_current_limit(struct tcpc_dev *dev)
+static void fusb302_flush_rx_fifo(struct fusb30x_chip *chip)
 {
-	struct fusb302_chip *chip = container_of(dev, struct fusb302_chip,
-						 tcpc_dev);
-	int current_limit = 0;
-	unsigned long timeout;
-
-	if (!chip->extcon)
-		return 0;
-
-	/*
-	 * USB2 Charger detection may still be in progress when we get here,
-	 * this can take upto 600ms, wait 800ms max.
-	 */
-	timeout = jiffies + msecs_to_jiffies(800);
-	do {
-		if (extcon_get_state(chip->extcon, EXTCON_CHG_USB_SDP) == 1)
-			current_limit = 500;
-
-		if (extcon_get_state(chip->extcon, EXTCON_CHG_USB_CDP) == 1 ||
-		    extcon_get_state(chip->extcon, EXTCON_CHG_USB_ACA) == 1)
-			current_limit = 1500;
-
-		if (extcon_get_state(chip->extcon, EXTCON_CHG_USB_DCP) == 1)
-			current_limit = 2000;
-
-		msleep(50);
-	} while (current_limit == 0 && time_before(jiffies, timeout));
-
-	return current_limit;
+	regmap_write(chip->regmap, FUSB_REG_CONTROL1, CONTROL1_RX_FLUSH);
 }
 
-static int fusb302_set_src_current(struct fusb302_chip *chip,
-				   enum src_current_status status)
+static int tcpm_get_cc(struct fusb30x_chip *chip, int *CC1, int *CC2)
 {
-	int ret = 0;
+	u32 val;
+	int *CC_MEASURE;
+	u32 store;
 
-	chip->src_current_status = status;
-	switch (status) {
-	case SRC_CURRENT_DEFAULT:
-		ret = fusb302_i2c_mask_write(chip, FUSB_REG_CONTROL0,
-					     FUSB_REG_CONTROL0_HOST_CUR_MASK,
-					     FUSB_REG_CONTROL0_HOST_CUR_DEF);
-		break;
-	case SRC_CURRENT_MEDIUM:
-		ret = fusb302_i2c_mask_write(chip, FUSB_REG_CONTROL0,
-					     FUSB_REG_CONTROL0_HOST_CUR_MASK,
-					     FUSB_REG_CONTROL0_HOST_CUR_MED);
-		break;
-	case SRC_CURRENT_HIGH:
-		ret = fusb302_i2c_mask_write(chip, FUSB_REG_CONTROL0,
-					     FUSB_REG_CONTROL0_HOST_CUR_MASK,
-					     FUSB_REG_CONTROL0_HOST_CUR_HIGH);
-		break;
-	default:
-		break;
+	*CC1 = TYPEC_CC_VOLT_OPEN;
+	*CC2 = TYPEC_CC_VOLT_OPEN;
+
+	if (chip->cc_state & CC_STATE_TOGSS_CC1)
+		CC_MEASURE = CC1;
+	else
+		CC_MEASURE = CC2;
+
+	if (chip->cc_state & CC_STATE_TOGSS_IS_UFP) {
+		regmap_read(chip->regmap, FUSB_REG_SWITCHES0, &store);
+		/* measure cc1 first */
+		regmap_update_bits(chip->regmap, FUSB_REG_SWITCHES0,
+				   SWITCHES0_MEAS_CC1 | SWITCHES0_MEAS_CC2 |
+				   SWITCHES0_PU_EN1 | SWITCHES0_PU_EN2 |
+				   SWITCHES0_PDWN1 | SWITCHES0_PDWN2,
+				   SWITCHES0_PDWN1 | SWITCHES0_PDWN2 |
+				   SWITCHES0_MEAS_CC1);
+		usleep_range(250, 300);
+
+		regmap_read(chip->regmap, FUSB_REG_STATUS0, &val);
+		val &= STATUS0_BC_LVL;
+		*CC1 = val ? TYPEC_CC_VOLT_RP : TYPEC_CC_VOLT_OPEN;
+
+		regmap_update_bits(chip->regmap, FUSB_REG_SWITCHES0,
+				   SWITCHES0_MEAS_CC1 | SWITCHES0_MEAS_CC2 |
+				   SWITCHES0_PU_EN1 | SWITCHES0_PU_EN2 |
+				   SWITCHES0_PDWN1 | SWITCHES0_PDWN2,
+				   SWITCHES0_PDWN1 | SWITCHES0_PDWN2 |
+				   SWITCHES0_MEAS_CC2);
+		usleep_range(250, 300);
+
+		regmap_read(chip->regmap, FUSB_REG_STATUS0, &val);
+		val &= STATUS0_BC_LVL;
+		*CC2 = val ? TYPEC_CC_VOLT_RP : TYPEC_CC_VOLT_OPEN;
+
+		regmap_update_bits(chip->regmap, FUSB_REG_SWITCHES0,
+				   SWITCHES0_MEAS_CC1 | SWITCHES0_MEAS_CC2,
+				   store);
+	} else {
+		regmap_read(chip->regmap, FUSB_REG_SWITCHES0, &store);
+		val = store;
+		val &= ~(SWITCHES0_MEAS_CC1 | SWITCHES0_MEAS_CC2 |
+				SWITCHES0_PU_EN1 | SWITCHES0_PU_EN2);
+		if (chip->cc_state & CC_STATE_TOGSS_CC1) {
+			val |= SWITCHES0_MEAS_CC1 | SWITCHES0_PU_EN1;
+		} else {
+			val |= SWITCHES0_MEAS_CC2 | SWITCHES0_PU_EN2;
+		}
+		regmap_write(chip->regmap, FUSB_REG_SWITCHES0, val);
+
+		regmap_write(chip->regmap, FUSB_REG_MEASURE, chip->cc_meas_high);
+		usleep_range(250, 300);
+
+		regmap_read(chip->regmap, FUSB_REG_STATUS0, &val);
+		if (val & STATUS0_COMP) {
+			int retry = 3;
+			int comp_times = 0;
+
+			while (retry--) {
+				regmap_write(chip->regmap, FUSB_REG_MEASURE, chip->cc_meas_high);
+				usleep_range(250, 300);
+				regmap_read(chip->regmap, FUSB_REG_STATUS0, &val);
+				if (val & STATUS0_COMP) {
+					comp_times++;
+					if (comp_times == 3) {
+						*CC_MEASURE = TYPEC_CC_VOLT_OPEN;
+						regmap_write(chip->regmap, FUSB_REG_SWITCHES0, store);
+					}
+				}
+			}
+		} else {
+			regmap_write(chip->regmap, FUSB_REG_MEASURE, chip->cc_meas_low);
+			regmap_read(chip->regmap, FUSB_REG_MEASURE, &val);
+			usleep_range(250, 300);
+
+			regmap_read(chip->regmap, FUSB_REG_STATUS0, &val);
+
+			if (val & STATUS0_COMP)
+				*CC_MEASURE = TYPEC_CC_VOLT_RD;
+			else
+				*CC_MEASURE = TYPEC_CC_VOLT_RA;
+		}
+		regmap_write(chip->regmap, FUSB_REG_SWITCHES0, store);
+		regmap_write(chip->regmap, FUSB_REG_MEASURE,
+			     chip->cc_meas_high);
 	}
 
-	return ret;
+	return 0;
 }
 
-static int fusb302_set_toggling(struct fusb302_chip *chip,
-				enum toggling_mode mode)
+static void tcpm_set_cc_pull_mode(struct fusb30x_chip *chip, enum CC_MODE mode)
 {
-	int ret = 0;
+	u8 val;
 
-	/* first disable toggling */
-	ret = fusb302_i2c_clear_bits(chip, FUSB_REG_CONTROL2,
-				     FUSB_REG_CONTROL2_TOGGLE);
-	if (ret < 0)
-		return ret;
-	/* mask interrupts for SRC or SNK */
-	ret = fusb302_i2c_set_bits(chip, FUSB_REG_MASK,
-				   FUSB_REG_MASK_BC_LVL |
-				   FUSB_REG_MASK_COMP_CHNG);
-	if (ret < 0)
-		return ret;
-	chip->intr_bc_lvl = false;
-	chip->intr_comp_chng = false;
-	/* configure toggling mode: none/snk/src/drp */
 	switch (mode) {
-	case TOGGLING_MODE_OFF:
-		ret = fusb302_i2c_mask_write(chip, FUSB_REG_CONTROL2,
-					     FUSB_REG_CONTROL2_MODE_MASK,
-					     FUSB_REG_CONTROL2_MODE_NONE);
-		if (ret < 0)
-			return ret;
-		break;
-	case TOGGLING_MODE_SNK:
-		ret = fusb302_i2c_mask_write(chip, FUSB_REG_CONTROL2,
-					     FUSB_REG_CONTROL2_MODE_MASK,
-					     FUSB_REG_CONTROL2_MODE_UFP);
-		if (ret < 0)
-			return ret;
-		break;
-	case TOGGLING_MODE_SRC:
-		ret = fusb302_i2c_mask_write(chip, FUSB_REG_CONTROL2,
-					     FUSB_REG_CONTROL2_MODE_MASK,
-					     FUSB_REG_CONTROL2_MODE_DFP);
-		if (ret < 0)
-			return ret;
-		break;
-	case TOGGLING_MODE_DRP:
-		ret = fusb302_i2c_mask_write(chip, FUSB_REG_CONTROL2,
-					     FUSB_REG_CONTROL2_MODE_MASK,
-					     FUSB_REG_CONTROL2_MODE_DRP);
-		if (ret < 0)
-			return ret;
+	case CC_PULL_UP:
+		if (chip->cc_polarity == TYPEC_POLARITY_CC1)
+			val = SWITCHES0_PU_EN1;
+		else
+			val = SWITCHES0_PU_EN2;
+		break;
+	case CC_PULL_DOWN:
+		val = SWITCHES0_PDWN1 | SWITCHES0_PDWN2;
 		break;
 	default:
+		val = 0;
 		break;
 	}
 
-	if (mode == TOGGLING_MODE_OFF) {
-		/* mask TOGDONE interrupt */
-		ret = fusb302_i2c_set_bits(chip, FUSB_REG_MASKA,
-					   FUSB_REG_MASKA_TOGDONE);
-		if (ret < 0)
-			return ret;
-		chip->intr_togdone = false;
-	} else {
-		/* Datasheet says vconn MUST be off when toggling */
-		WARN(chip->vconn_on, "Vconn is on during toggle start");
-		/* unmask TOGDONE interrupt */
-		ret = fusb302_i2c_clear_bits(chip, FUSB_REG_MASKA,
-					     FUSB_REG_MASKA_TOGDONE);
-		if (ret < 0)
-			return ret;
-		chip->intr_togdone = true;
-		/* start toggling */
-		ret = fusb302_i2c_set_bits(chip, FUSB_REG_CONTROL2,
-					   FUSB_REG_CONTROL2_TOGGLE);
-		if (ret < 0)
-			return ret;
-		/* during toggling, consider cc as Open */
-		chip->cc1 = TYPEC_CC_OPEN;
-		chip->cc2 = TYPEC_CC_OPEN;
-	}
-	chip->toggling_mode = mode;
+	regmap_update_bits(chip->regmap, FUSB_REG_SWITCHES0,
+			   SWITCHES0_PU_EN1 | SWITCHES0_PU_EN2 |
+			   SWITCHES0_PDWN1 | SWITCHES0_PDWN2,
+			   val);
 
-	return ret;
+	if (chip->cc_meas_high && mode == CC_PULL_UP)
+		regmap_write(chip->regmap, FUSB_REG_MEASURE,
+			     chip->cc_meas_high);
 }
 
-static const char * const typec_cc_status_name[] = {
-	[TYPEC_CC_OPEN]		= "Open",
-	[TYPEC_CC_RA]		= "Ra",
-	[TYPEC_CC_RD]		= "Rd",
-	[TYPEC_CC_RP_DEF]	= "Rp-def",
-	[TYPEC_CC_RP_1_5]	= "Rp-1.5",
-	[TYPEC_CC_RP_3_0]	= "Rp-3.0",
-};
-
-static const enum src_current_status cc_src_current[] = {
-	[TYPEC_CC_OPEN]		= SRC_CURRENT_DEFAULT,
-	[TYPEC_CC_RA]		= SRC_CURRENT_DEFAULT,
-	[TYPEC_CC_RD]		= SRC_CURRENT_DEFAULT,
-	[TYPEC_CC_RP_DEF]	= SRC_CURRENT_DEFAULT,
-	[TYPEC_CC_RP_1_5]	= SRC_CURRENT_MEDIUM,
-	[TYPEC_CC_RP_3_0]	= SRC_CURRENT_HIGH,
-};
-
-static int tcpm_set_cc(struct tcpc_dev *dev, enum typec_cc_status cc)
+static int tcpm_set_cc(struct fusb30x_chip *chip, enum role_mode mode)
 {
-	struct fusb302_chip *chip = container_of(dev, struct fusb302_chip,
-						 tcpc_dev);
-	u8 switches0_mask = FUSB_REG_SWITCHES0_CC1_PU_EN |
-			    FUSB_REG_SWITCHES0_CC2_PU_EN |
-			    FUSB_REG_SWITCHES0_CC1_PD_EN |
-			    FUSB_REG_SWITCHES0_CC2_PD_EN;
-	u8 rd_mda, switches0_data = 0x00;
-	int ret = 0;
-
-	mutex_lock(&chip->lock);
-	switch (cc) {
-	case TYPEC_CC_OPEN:
-		break;
-	case TYPEC_CC_RD:
-		switches0_data |= FUSB_REG_SWITCHES0_CC1_PD_EN |
-				  FUSB_REG_SWITCHES0_CC2_PD_EN;
+	switch (mode) {
+	case ROLE_MODE_DFP:
+		tcpm_set_cc_pull_mode(chip, CC_PULL_UP);
+		regmap_update_bits(chip->regmap, FUSB_REG_CONTROL2,
+				   CONTROL2_MODE | CONTROL2_TOG_RD_ONLY,
+				   CONTROL2_MODE_DFP | CONTROL2_TOG_RD_ONLY);
 		break;
-	case TYPEC_CC_RP_DEF:
-	case TYPEC_CC_RP_1_5:
-	case TYPEC_CC_RP_3_0:
-		switches0_data |= (chip->cc_polarity == TYPEC_POLARITY_CC1) ?
-				  FUSB_REG_SWITCHES0_CC1_PU_EN :
-				  FUSB_REG_SWITCHES0_CC2_PU_EN;
+	case ROLE_MODE_UFP:
+		tcpm_set_cc_pull_mode(chip, CC_PULL_UP);
+		regmap_update_bits(chip->regmap, FUSB_REG_CONTROL2,
+				   CONTROL2_MODE | CONTROL2_TOG_RD_ONLY,
+				   CONTROL2_MODE_UFP);
 		break;
-	default:
-		fusb302_log(chip, "unsupported cc value %s",
-			    typec_cc_status_name[cc]);
-		ret = -EINVAL;
-		goto done;
-	}
-
-	fusb302_log(chip, "cc := %s", typec_cc_status_name[cc]);
-
-	ret = fusb302_set_toggling(chip, TOGGLING_MODE_OFF);
-	if (ret < 0) {
-		fusb302_log(chip, "cannot set toggling mode, ret=%d", ret);
-		goto done;
-	}
-
-	ret = fusb302_i2c_mask_write(chip, FUSB_REG_SWITCHES0,
-				     switches0_mask, switches0_data);
-	if (ret < 0) {
-		fusb302_log(chip, "cannot set pull-up/-down, ret = %d", ret);
-		goto done;
-	}
-	/* reset the cc status */
-	chip->cc1 = TYPEC_CC_OPEN;
-	chip->cc2 = TYPEC_CC_OPEN;
-
-	/* adjust current for SRC */
-	ret = fusb302_set_src_current(chip, cc_src_current[cc]);
-	if (ret < 0) {
-		fusb302_log(chip, "cannot set src current %s, ret=%d",
-			    typec_cc_status_name[cc], ret);
-		goto done;
-	}
-
-	/* enable/disable interrupts, BC_LVL for SNK and COMP_CHNG for SRC */
-	switch (cc) {
-	case TYPEC_CC_RP_DEF:
-	case TYPEC_CC_RP_1_5:
-	case TYPEC_CC_RP_3_0:
-		rd_mda = rd_mda_value[cc_src_current[cc]];
-		ret = fusb302_i2c_write(chip, FUSB_REG_MEASURE, rd_mda);
-		if (ret < 0) {
-			fusb302_log(chip,
-				    "cannot set SRC measure value, ret=%d",
-				    ret);
-			goto done;
-		}
-		ret = fusb302_i2c_mask_write(chip, FUSB_REG_MASK,
-					     FUSB_REG_MASK_BC_LVL |
-					     FUSB_REG_MASK_COMP_CHNG,
-					     FUSB_REG_MASK_COMP_CHNG);
-		if (ret < 0) {
-			fusb302_log(chip, "cannot set SRC interrupt, ret=%d",
-				    ret);
-			goto done;
-		}
-		chip->intr_comp_chng = true;
-		break;
-	case TYPEC_CC_RD:
-		ret = fusb302_i2c_mask_write(chip, FUSB_REG_MASK,
-					     FUSB_REG_MASK_BC_LVL |
-					     FUSB_REG_MASK_COMP_CHNG,
-					     FUSB_REG_MASK_BC_LVL);
-		if (ret < 0) {
-			fusb302_log(chip, "cannot set SRC interrupt, ret=%d",
-				    ret);
-			goto done;
-		}
-		chip->intr_bc_lvl = true;
+	case ROLE_MODE_DRP:
+		tcpm_set_cc_pull_mode(chip, CC_PULL_NONE);
+		regmap_update_bits(chip->regmap, FUSB_REG_CONTROL2,
+				   CONTROL2_MODE | CONTROL2_TOG_RD_ONLY,
+				   CONTROL2_MODE_DRP | CONTROL2_TOG_RD_ONLY);
 		break;
 	default:
+		dev_err(chip->dev, "%s: Unsupport cc mode %d\n",
+			__func__, mode);
+		return -EINVAL;
 		break;
 	}
-done:
-	mutex_unlock(&chip->lock);
 
-	return ret;
+	regmap_update_bits(chip->regmap, FUSB_REG_CONTROL2, CONTROL2_TOGGLE,
+			   CONTROL2_TOGGLE);
+
+	return 0;
 }
 
-static int tcpm_get_cc(struct tcpc_dev *dev, enum typec_cc_status *cc1,
-		       enum typec_cc_status *cc2)
+static int tcpm_set_rx_enable(struct fusb30x_chip *chip, int enable)
 {
-	struct fusb302_chip *chip = container_of(dev, struct fusb302_chip,
-						 tcpc_dev);
+	u8 val = 0;
 
-	mutex_lock(&chip->lock);
-	*cc1 = chip->cc1;
-	*cc2 = chip->cc2;
-	fusb302_log(chip, "cc1=%s, cc2=%s", typec_cc_status_name[*cc1],
-		    typec_cc_status_name[*cc2]);
-	mutex_unlock(&chip->lock);
+	if (enable) {
+		if (chip->cc_polarity == TYPEC_POLARITY_CC1)
+			val |= SWITCHES0_MEAS_CC1;
+		else
+			val |= SWITCHES0_MEAS_CC2;
+		regmap_update_bits(chip->regmap, FUSB_REG_SWITCHES0,
+				   SWITCHES0_MEAS_CC1 | SWITCHES0_MEAS_CC2,
+				   val);
+		fusb302_flush_rx_fifo(chip);
+		regmap_update_bits(chip->regmap, FUSB_REG_SWITCHES1,
+				   SWITCHES1_AUTO_CRC, SWITCHES1_AUTO_CRC);
+	} else {
+		regmap_update_bits(chip->regmap, FUSB_REG_SWITCHES0,
+				   SWITCHES0_MEAS_CC1 | SWITCHES0_MEAS_CC2,
+				   0);
+		regmap_update_bits(chip->regmap,
+				   FUSB_REG_SWITCHES1, SWITCHES1_AUTO_CRC, 0);
+	}
 
 	return 0;
 }
 
-static int tcpm_set_polarity(struct tcpc_dev *dev,
-			     enum typec_cc_polarity polarity)
+static int tcpm_set_msg_header(struct fusb30x_chip *chip)
 {
+	regmap_update_bits(chip->regmap, FUSB_REG_SWITCHES1,
+			   SWITCHES1_POWERROLE | SWITCHES1_DATAROLE,
+			   (chip->notify.power_role << 7) |
+			   (chip->notify.data_role << 4));
+	regmap_update_bits(chip->regmap, FUSB_REG_SWITCHES1,
+			   SWITCHES1_SPECREV, 2 << 5);
 	return 0;
 }
 
-static int tcpm_set_vconn(struct tcpc_dev *dev, bool on)
+static int tcpm_set_polarity(struct fusb30x_chip *chip,
+			     enum typec_cc_polarity polarity)
 {
-	struct fusb302_chip *chip = container_of(dev, struct fusb302_chip,
-						 tcpc_dev);
-	int ret = 0;
-	u8 switches0_data = 0x00;
-	u8 switches0_mask = FUSB_REG_SWITCHES0_VCONN_CC1 |
-			    FUSB_REG_SWITCHES0_VCONN_CC2;
+	u8 val = 0;
 
-	mutex_lock(&chip->lock);
-	if (chip->vconn_on == on) {
-		fusb302_log(chip, "vconn is already %s", on ? "On" : "Off");
-		goto done;
+	if (chip->vconn_enabled) {
+		if (polarity)
+			val |= SWITCHES0_VCONN_CC1;
+		else
+			val |= SWITCHES0_VCONN_CC2;
 	}
-	if (on) {
-		switches0_data = (chip->cc_polarity == TYPEC_POLARITY_CC1) ?
-				 FUSB_REG_SWITCHES0_VCONN_CC2 :
-				 FUSB_REG_SWITCHES0_VCONN_CC1;
-	}
-	ret = fusb302_i2c_mask_write(chip, FUSB_REG_SWITCHES0,
-				     switches0_mask, switches0_data);
-	if (ret < 0)
-		goto done;
-	chip->vconn_on = on;
-	fusb302_log(chip, "vconn := %s", on ? "On" : "Off");
-done:
-	mutex_unlock(&chip->lock);
-
-	return ret;
-}
 
-static int tcpm_set_vbus(struct tcpc_dev *dev, bool on, bool charge)
-{
-	struct fusb302_chip *chip = container_of(dev, struct fusb302_chip,
-						 tcpc_dev);
-	int ret = 0;
-
-	mutex_lock(&chip->lock);
-	if (chip->vbus_on == on) {
-		fusb302_log(chip, "vbus is already %s", on ? "On" : "Off");
+	if (chip->cc_state & CC_STATE_TOGSS_IS_UFP) {
+		if (polarity == TYPEC_POLARITY_CC1)
+			val |= SWITCHES0_MEAS_CC1;
+		else
+			val |= SWITCHES0_MEAS_CC2;
 	} else {
-		if (on)
-			ret = regulator_enable(chip->vbus);
+		if (polarity == TYPEC_POLARITY_CC1)
+			val |= SWITCHES0_MEAS_CC1 | SWITCHES0_PU_EN1;
 		else
-			ret = regulator_disable(chip->vbus);
-		if (ret < 0) {
-			fusb302_log(chip, "cannot %s vbus regulator, ret=%d",
-				    on ? "enable" : "disable", ret);
-			goto done;
-		}
-		chip->vbus_on = on;
-		fusb302_log(chip, "vbus := %s", on ? "On" : "Off");
-	}
-	if (chip->charge_on == charge)
-		fusb302_log(chip, "charge is already %s",
-			    charge ? "On" : "Off");
+			val |= SWITCHES0_MEAS_CC2 | SWITCHES0_PU_EN2;
+	}
+
+	regmap_update_bits(chip->regmap, FUSB_REG_SWITCHES0,
+			   SWITCHES0_VCONN_CC1 | SWITCHES0_VCONN_CC2 |
+			   SWITCHES0_MEAS_CC1 | SWITCHES0_MEAS_CC2 |
+			   SWITCHES0_PU_EN1 | SWITCHES0_PU_EN2,
+			   val);
+
+	val = 0;
+	if (polarity == TYPEC_POLARITY_CC1)
+		val |= SWITCHES1_TXCC1;
 	else
-		chip->charge_on = charge;
+		val |= SWITCHES1_TXCC2;
+	regmap_update_bits(chip->regmap, FUSB_REG_SWITCHES1,
+			   SWITCHES1_TXCC1 | SWITCHES1_TXCC2,
+			   val);
 
-done:
-	mutex_unlock(&chip->lock);
+	chip->cc_polarity = polarity;
 
-	return ret;
+	return 0;
 }
 
-static int fusb302_pd_tx_flush(struct fusb302_chip *chip)
+static int tcpm_set_vconn(struct fusb30x_chip *chip, int enable)
 {
-	return fusb302_i2c_set_bits(chip, FUSB_REG_CONTROL0,
-				    FUSB_REG_CONTROL0_TX_FLUSH);
-}
+	u8 val = 0;
 
-static int fusb302_pd_rx_flush(struct fusb302_chip *chip)
-{
-	return fusb302_i2c_set_bits(chip, FUSB_REG_CONTROL1,
-				    FUSB_REG_CONTROL1_RX_FLUSH);
+	if (enable) {
+		if (chip->cc_polarity == TYPEC_POLARITY_CC1)
+			val = SWITCHES0_VCONN_CC2;
+		else
+			val = SWITCHES0_VCONN_CC1;
+	}
+	regmap_update_bits(chip->regmap, FUSB_REG_SWITCHES0,
+			   SWITCHES0_VCONN_CC1 | SWITCHES0_VCONN_CC2,
+			   val);
+	chip->vconn_enabled = (bool)enable;
+	return 0;
 }
 
-static int fusb302_pd_set_auto_goodcrc(struct fusb302_chip *chip, bool on)
+static void fusb302_pd_reset(struct fusb30x_chip *chip)
 {
-	if (on)
-		return fusb302_i2c_set_bits(chip, FUSB_REG_SWITCHES1,
-					    FUSB_REG_SWITCHES1_AUTO_GCRC);
-	return fusb302_i2c_clear_bits(chip, FUSB_REG_SWITCHES1,
-					    FUSB_REG_SWITCHES1_AUTO_GCRC);
+	regmap_write(chip->regmap, FUSB_REG_RESET, RESET_PD_RESET);
+	regmap_reinit_cache(chip->regmap, &fusb302_regmap_config);
 }
 
-static int fusb302_pd_set_interrupts(struct fusb302_chip *chip, bool on)
+static void tcpm_select_rp_value(struct fusb30x_chip *chip, u32 rp)
 {
-	int ret = 0;
-	u8 mask_interrupts = FUSB_REG_MASK_COLLISION;
-	u8 maska_interrupts = FUSB_REG_MASKA_RETRYFAIL |
-			      FUSB_REG_MASKA_HARDSENT |
-			      FUSB_REG_MASKA_TX_SUCCESS |
-			      FUSB_REG_MASKA_HARDRESET;
-	u8 maskb_interrupts = FUSB_REG_MASKB_GCRCSENT;
-
-	ret = on ?
-		fusb302_i2c_clear_bits(chip, FUSB_REG_MASK, mask_interrupts) :
-		fusb302_i2c_set_bits(chip, FUSB_REG_MASK, mask_interrupts);
-	if (ret < 0)
-		return ret;
-	ret = on ?
-		fusb302_i2c_clear_bits(chip, FUSB_REG_MASKA, maska_interrupts) :
-		fusb302_i2c_set_bits(chip, FUSB_REG_MASKA, maska_interrupts);
-	if (ret < 0)
-		return ret;
-	ret = on ?
-		fusb302_i2c_clear_bits(chip, FUSB_REG_MASKB, maskb_interrupts) :
-		fusb302_i2c_set_bits(chip, FUSB_REG_MASKB, maskb_interrupts);
-	return ret;
-}
+	u32 control0_reg;
 
-static int tcpm_set_pd_rx(struct tcpc_dev *dev, bool on)
-{
-	struct fusb302_chip *chip = container_of(dev, struct fusb302_chip,
-						 tcpc_dev);
-	int ret = 0;
+	regmap_read(chip->regmap, FUSB_REG_CONTROL0, &control0_reg);
 
-	mutex_lock(&chip->lock);
-	ret = fusb302_pd_rx_flush(chip);
-	if (ret < 0) {
-		fusb302_log(chip, "cannot flush pd rx buffer, ret=%d", ret);
-		goto done;
-	}
-	ret = fusb302_pd_tx_flush(chip);
-	if (ret < 0) {
-		fusb302_log(chip, "cannot flush pd tx buffer, ret=%d", ret);
-		goto done;
-	}
-	ret = fusb302_pd_set_auto_goodcrc(chip, on);
-	if (ret < 0) {
-		fusb302_log(chip, "cannot turn %s auto GCRC, ret=%d",
-			    on ? "on" : "off", ret);
-		goto done;
-	}
-	ret = fusb302_pd_set_interrupts(chip, on);
-	if (ret < 0) {
-		fusb302_log(chip, "cannot turn %s pd interrupts, ret=%d",
-			    on ? "on" : "off", ret);
-		goto done;
+	control0_reg &= ~CONTROL0_HOST_CUR;
+	/*
+	 * according to the host current, the compare value is different
+	 * Fusb302 datasheet Table 3
+	 */
+	switch (rp) {
+	/*
+	 * host pull up current is 80ua , high voltage is 1.596v,
+	 * low is 0.21v
+	 */
+	case TYPEC_RP_USB:
+		chip->cc_meas_high = 0x26;
+		chip->cc_meas_low = 0x5;
+		control0_reg |= CONTROL0_HOST_CUR_USB;
+		break;
+	/*
+	 * host pull up current is 330ua , high voltage is 2.604v,
+	 * low is 0.798v
+	 */
+	case TYPEC_RP_3A0:
+		chip->cc_meas_high = 0x3e;
+		chip->cc_meas_low = 0x13;
+		control0_reg |= CONTROL0_HOST_CUR_3A0;
+		break;
+	/*
+	 * host pull up current is 180ua , high voltage is 1.596v,
+	 * low is 0.42v
+	 */
+	case TYPEC_RP_1A5:
+	default:
+		chip->cc_meas_high = 0x26;
+		chip->cc_meas_low = 0xa;
+		control0_reg |= CONTROL0_HOST_CUR_1A5;
+		break;
 	}
-	fusb302_log(chip, "pd := %s", on ? "on" : "off");
-done:
-	mutex_unlock(&chip->lock);
 
-	return ret;
+	regmap_write(chip->regmap, FUSB_REG_CONTROL0, control0_reg);
 }
 
-static const char * const typec_role_name[] = {
-	[TYPEC_SINK]		= "Sink",
-	[TYPEC_SOURCE]		= "Source",
-};
+static int tcpm_check_vbus(struct fusb30x_chip *chip)
+{
+	u32 val;
 
-static const char * const typec_data_role_name[] = {
-	[TYPEC_DEVICE]		= "Device",
-	[TYPEC_HOST]		= "Host",
-};
+	/* Read status register */
+	regmap_read(chip->regmap, FUSB_REG_STATUS0, &val);
 
-static int tcpm_set_roles(struct tcpc_dev *dev, bool attached,
-			  enum typec_role pwr, enum typec_data_role data)
-{
-	struct fusb302_chip *chip = container_of(dev, struct fusb302_chip,
-						 tcpc_dev);
-	int ret = 0;
-	u8 switches1_mask = FUSB_REG_SWITCHES1_POWERROLE |
-			    FUSB_REG_SWITCHES1_DATAROLE;
-	u8 switches1_data = 0x00;
-
-	mutex_lock(&chip->lock);
-	if (pwr == TYPEC_SOURCE)
-		switches1_data |= FUSB_REG_SWITCHES1_POWERROLE;
-	if (data == TYPEC_HOST)
-		switches1_data |= FUSB_REG_SWITCHES1_DATAROLE;
-	ret = fusb302_i2c_mask_write(chip, FUSB_REG_SWITCHES1,
-				     switches1_mask, switches1_data);
-	if (ret < 0) {
-		fusb302_log(chip, "unable to set pd header %s, %s, ret=%d",
-			    typec_role_name[pwr], typec_data_role_name[data],
-			    ret);
-		goto done;
-	}
-	fusb302_log(chip, "pd header := %s, %s", typec_role_name[pwr],
-		    typec_data_role_name[data]);
-done:
-	mutex_unlock(&chip->lock);
+	return (val & STATUS0_VBUSOK) ? 1 : 0;
+}
 
-	return ret;
+static void tcpm_init(struct fusb30x_chip *chip)
+{
+	u8 val;
+	u32 tmp;
+
+	regmap_read(chip->regmap, FUSB_REG_DEVICEID, &tmp);
+	chip->chip_id = (u8)tmp;
+	platform_set_vbus_lvl_enable(chip, 0, 0);
+	chip->notify.is_cc_connected = false;
+	chip->cc_state = 0;
+
+	/* restore default settings */
+	regmap_update_bits(chip->regmap, FUSB_REG_RESET, RESET_SW_RESET,
+			   RESET_SW_RESET);
+	fusb302_pd_reset(chip);
+	/* set auto_retry and number of retries */
+	regmap_update_bits(chip->regmap, FUSB_REG_CONTROL3,
+			   CONTROL3_AUTO_RETRY | CONTROL3_N_RETRIES,
+			   CONTROL3_AUTO_RETRY | CONTROL3_N_RETRIES),
+
+	/* set interrupts */
+	val = 0xff;
+	val &= ~(MASK_M_COLLISION | MASK_M_ALERT | MASK_M_VBUSOK);
+	regmap_write(chip->regmap, FUSB_REG_MASK, val);
+
+	val = 0xff;
+	val &= ~(MASKA_M_RETRYFAIL | MASKA_M_HARDSENT | MASKA_M_TXSENT |
+		 MASKA_M_HARDRST | MASKA_M_TOGDONE);
+	regmap_write(chip->regmap, FUSB_REG_MASKA, val);
+
+	val = ~MASKB_M_GCRCSEND;
+	regmap_write(chip->regmap, FUSB_REG_MASKB, val);
+
+	tcpm_select_rp_value(chip, TYPEC_RP_1A5);
+	/* Interrupts Enable */
+	regmap_update_bits(chip->regmap, FUSB_REG_CONTROL0, CONTROL0_INT_MASK,
+			   ~CONTROL0_INT_MASK);
+
+	tcpm_set_vconn(chip, 0);
+
+	regmap_write(chip->regmap, FUSB_REG_POWER, 0xf);
 }
 
-static int tcpm_start_toggling(struct tcpc_dev *dev,
-			       enum typec_port_type port_type,
-			       enum typec_cc_status cc)
+static void pd_execute_hard_reset(struct fusb30x_chip *chip)
 {
-	struct fusb302_chip *chip = container_of(dev, struct fusb302_chip,
-						 tcpc_dev);
-	enum toggling_mode mode = TOGGLING_MODE_OFF;
-	int ret = 0;
+	chip->msg_id = 0;
+	chip->vdm_state = VDM_STATE_DISCOVERY_ID;
+	if (chip->notify.power_role)
+		set_state(chip, policy_src_transition_default);
+	else
+		set_state(chip, policy_snk_transition_default);
+}
 
-	switch (port_type) {
-	case TYPEC_PORT_SRC:
-		mode = TOGGLING_MODE_SRC;
-		break;
-	case TYPEC_PORT_SNK:
-		mode = TOGGLING_MODE_SNK;
-		break;
-	case TYPEC_PORT_DRP:
-		mode = TOGGLING_MODE_DRP;
-		break;
+static void tcpc_alert(struct fusb30x_chip *chip, u32 *evt)
+{
+	int interrupt, interrupta, interruptb;
+	u32 val;
+	static int retry;
+
+	regmap_read(chip->regmap, FUSB_REG_INTERRUPT, &interrupt);
+	regmap_read(chip->regmap, FUSB_REG_INTERRUPTA, &interrupta);
+	regmap_read(chip->regmap, FUSB_REG_INTERRUPTB, &interruptb);
+
+	if ((interrupt & INTERRUPT_COMP_CHNG) &&
+	    (!(chip->cc_state & CC_STATE_TOGSS_IS_UFP))) {
+		regmap_read(chip->regmap, FUSB_REG_STATUS0, &val);
+		if (val & STATUS0_COMP)
+			*evt |= EVENT_CC;
 	}
 
-	mutex_lock(&chip->lock);
-	ret = fusb302_set_src_current(chip, cc_src_current[cc]);
-	if (ret < 0) {
-		fusb302_log(chip, "unable to set src current %s, ret=%d",
-			    typec_cc_status_name[cc], ret);
-		goto done;
+	if (interrupt & INTERRUPT_VBUSOK) {
+		if (chip->notify.is_cc_connected)
+			*evt |= EVENT_CC;
 	}
-	ret = fusb302_set_toggling(chip, mode);
-	if (ret < 0) {
-		fusb302_log(chip,
-			    "unable to start drp toggling, ret=%d", ret);
-		goto done;
+
+	if (interrupta & INTERRUPTA_TOGDONE) {
+		*evt |= EVENT_CC;
+		regmap_read(chip->regmap, FUSB_REG_STATUS1A, &val);
+		chip->cc_state = ((u8)val >> 3) & 0x07;
+
+		regmap_update_bits(chip->regmap, FUSB_REG_CONTROL2,
+				   CONTROL2_TOGGLE,
+				   0);
 	}
-	fusb302_log(chip, "start drp toggling");
-done:
-	mutex_unlock(&chip->lock);
 
-	return ret;
-}
+	if (interrupta & INTERRUPTA_TXSENT) {
+		*evt |= EVENT_TX;
+		chip->tx_state = tx_success;
+	}
 
-static int fusb302_pd_send_message(struct fusb302_chip *chip,
-				   const struct pd_message *msg)
-{
-	int ret = 0;
-	u8 buf[40];
-	u8 pos = 0;
-	int len;
+	if (interruptb & INTERRUPTB_GCRCSENT)
+		*evt |= EVENT_RX;
 
-	/* SOP tokens */
-	buf[pos++] = FUSB302_TKN_SYNC1;
-	buf[pos++] = FUSB302_TKN_SYNC1;
-	buf[pos++] = FUSB302_TKN_SYNC1;
-	buf[pos++] = FUSB302_TKN_SYNC2;
-
-	len = pd_header_cnt_le(msg->header) * 4;
-	/* plug 2 for header */
-	len += 2;
-	if (len > 0x1F) {
-		fusb302_log(chip,
-			    "PD message too long %d (incl. header)", len);
-		return -EINVAL;
+	if (interrupta & INTERRUPTA_HARDRST) {
+		fusb302_pd_reset(chip);
+		pd_execute_hard_reset(chip);
+		*evt |= EVENT_REC_RESET;
 	}
-	/* packsym tells the FUSB302 chip that the next X bytes are payload */
-	buf[pos++] = FUSB302_TKN_PACKSYM | (len & 0x1F);
-	memcpy(&buf[pos], &msg->header, sizeof(msg->header));
-	pos += sizeof(msg->header);
-
-	len -= 2;
-	memcpy(&buf[pos], msg->payload, len);
-	pos += len;
-
-	/* CRC */
-	buf[pos++] = FUSB302_TKN_JAMCRC;
-	/* EOP */
-	buf[pos++] = FUSB302_TKN_EOP;
-	/* turn tx off after sending message */
-	buf[pos++] = FUSB302_TKN_TXOFF;
-	/* start transmission */
-	buf[pos++] = FUSB302_TKN_TXON;
-
-	ret = fusb302_i2c_block_write(chip, FUSB_REG_FIFOS, pos, buf);
-	if (ret < 0)
-		return ret;
-	fusb302_log(chip, "sending PD message header: %x", msg->header);
-	fusb302_log(chip, "sending PD message len: %d", len);
 
-	return ret;
-}
+	if (interrupta & INTERRUPTA_RETRYFAIL) {
+		*evt |= EVENT_TX;
+		chip->tx_state = tx_failed;
+	}
 
-static int fusb302_pd_send_hardreset(struct fusb302_chip *chip)
-{
-	return fusb302_i2c_set_bits(chip, FUSB_REG_CONTROL3,
-				    FUSB_REG_CONTROL3_SEND_HARDRESET);
+	if (interrupta & INTERRUPTA_HARDSENT) {
+		/*
+		 * The fusb PD should be reset once to sync adapter PD
+		 * signal after fusb sent hard reset cmd.This is not PD
+		 * device if reset failed.
+		 */
+		if (!retry) {
+			retry = 1;
+			fusb302_pd_reset(chip);
+			pd_execute_hard_reset(chip);
+		} else {
+			retry = 0;
+			chip->tx_state = tx_success;
+			chip->timer_state = T_DISABLED;
+			*evt |= EVENT_TX;
+		}
+	}
 }
 
-static const char * const transmit_type_name[] = {
-	[TCPC_TX_SOP]			= "SOP",
-	[TCPC_TX_SOP_PRIME]		= "SOP'",
-	[TCPC_TX_SOP_PRIME_PRIME]	= "SOP''",
-	[TCPC_TX_SOP_DEBUG_PRIME]	= "DEBUG'",
-	[TCPC_TX_SOP_DEBUG_PRIME_PRIME]	= "DEBUG''",
-	[TCPC_TX_HARD_RESET]		= "HARD_RESET",
-	[TCPC_TX_CABLE_RESET]		= "CABLE_RESET",
-	[TCPC_TX_BIST_MODE_2]		= "BIST_MODE_2",
-};
-
-static int tcpm_pd_transmit(struct tcpc_dev *dev, enum tcpm_transmit_type type,
-			    const struct pd_message *msg)
+static void mux_alert(struct fusb30x_chip *chip, u32 *evt)
 {
-	struct fusb302_chip *chip = container_of(dev, struct fusb302_chip,
-						 tcpc_dev);
-	int ret = 0;
+	if (!chip->timer_mux) {
+		*evt |= EVENT_TIMER_MUX;
+		chip->timer_mux = T_DISABLED;
+	}
 
-	mutex_lock(&chip->lock);
-	switch (type) {
-	case TCPC_TX_SOP:
-		ret = fusb302_pd_send_message(chip, msg);
-		if (ret < 0)
-			fusb302_log(chip,
-				    "cannot send PD message, ret=%d", ret);
-		break;
-	case TCPC_TX_HARD_RESET:
-		ret = fusb302_pd_send_hardreset(chip);
-		if (ret < 0)
-			fusb302_log(chip,
-				    "cannot send hardreset, ret=%d", ret);
-		break;
-	default:
-		fusb302_log(chip, "type %s not supported",
-			    transmit_type_name[type]);
-		ret = -EINVAL;
+	if (!chip->timer_state) {
+		*evt |= EVENT_TIMER_STATE;
+		chip->timer_state = T_DISABLED;
 	}
-	mutex_unlock(&chip->lock);
 
-	return ret;
+	if (chip->work_continue) {
+		*evt |= chip->work_continue;
+		chip->work_continue = 0;
+	}
+}
+
+static void set_state_unattached(struct fusb30x_chip *chip)
+{
+	dev_info(chip->dev, "connection has disconnected\n");
+	tcpm_init(chip);
+	tcpm_set_rx_enable(chip, 0);
+	set_state(chip, unattached);
+	tcpm_set_cc(chip, chip->role);
+
+	/* claer notify_info */
+	memset(&chip->notify, 0, sizeof(struct notify_info));
+	platform_fusb_notify(chip);
+	usb_role_switch_set_role(chip->role_sw, USB_ROLE_NONE);
+
+	if (chip->gpio_discharge)
+		gpiod_set_value(chip->gpio_discharge, 1);
+	msleep(100);
+	if (chip->gpio_discharge)
+		gpiod_set_value(chip->gpio_discharge, 0);
+
+	regmap_update_bits(chip->regmap, FUSB_REG_MASK,
+			   MASK_M_COMP_CHNG, MASK_M_COMP_CHNG);
+	chip->try_role_complete = false;
 }
 
-static enum typec_cc_status fusb302_bc_lvl_to_cc(u8 bc_lvl)
-{
-	if (bc_lvl == FUSB_REG_STATUS0_BC_LVL_1230_MAX)
-		return TYPEC_CC_RP_3_0;
-	if (bc_lvl == FUSB_REG_STATUS0_BC_LVL_600_1230)
-		return TYPEC_CC_RP_1_5;
-	if (bc_lvl == FUSB_REG_STATUS0_BC_LVL_200_600)
-		return TYPEC_CC_RP_DEF;
-	return TYPEC_CC_OPEN;
-}
-
-static void fusb302_bc_lvl_handler_work(struct work_struct *work)
-{
-	struct fusb302_chip *chip = container_of(work, struct fusb302_chip,
-						 bc_lvl_handler.work);
-	int ret = 0;
-	u8 status0;
-	u8 bc_lvl;
-	enum typec_cc_status cc_status;
-
-	mutex_lock(&chip->lock);
-	if (!chip->intr_bc_lvl) {
-		fusb302_log(chip, "BC_LVL interrupt is turned off, abort");
-		goto done;
-	}
-	ret = fusb302_i2c_read(chip, FUSB_REG_STATUS0, &status0);
-	if (ret < 0)
-		goto done;
-	fusb302_log(chip, "BC_LVL handler, status0=0x%02x", status0);
-	if (status0 & FUSB_REG_STATUS0_ACTIVITY) {
-		fusb302_log(chip, "CC activities detected, delay handling");
-		mod_delayed_work(chip->wq, &chip->bc_lvl_handler,
-				 msecs_to_jiffies(T_BC_LVL_DEBOUNCE_DELAY_MS));
-		goto done;
-	}
-	bc_lvl = status0 & FUSB_REG_STATUS0_BC_LVL_MASK;
-	cc_status = fusb302_bc_lvl_to_cc(bc_lvl);
-	if (chip->cc_polarity == TYPEC_POLARITY_CC1) {
-		if (chip->cc1 != cc_status) {
-			fusb302_log(chip, "cc1: %s -> %s",
-				    typec_cc_status_name[chip->cc1],
-				    typec_cc_status_name[cc_status]);
-			chip->cc1 = cc_status;
-			tcpm_cc_change(chip->tcpm_port);
+static void set_mesg(struct fusb30x_chip *chip, int cmd, int is_DMT)
+{
+	int i;
+	struct PD_CAP_INFO *pd_cap_info = &chip->pd_cap_info;
+
+	chip->send_head = ((chip->msg_id & 0x7) << 9) |
+			 ((chip->notify.power_role & 0x1) << 8) |
+			 (1 << 6) |
+			 ((chip->notify.data_role & 0x1) << 5);
+
+	if (is_DMT) {
+		switch (cmd) {
+		case DMT_SOURCECAPABILITIES:
+			chip->send_head |= ((chip->n_caps_used & 0x3) << 12) | (cmd & 0xf);
+
+			for (i = 0; i < chip->n_caps_used; i++) {
+				chip->send_load[i] = (pd_cap_info->supply_type << 30) |
+						    (pd_cap_info->dual_role_power << 29) |
+						    (pd_cap_info->usb_suspend_support << 28) |
+						    (pd_cap_info->externally_powered << 27) |
+						    (pd_cap_info->usb_communications_cap << 26) |
+						    (pd_cap_info->data_role_swap << 25) |
+						    (pd_cap_info->peak_current << 20) |
+						    (chip->source_power_supply[i] << 10) |
+						    (chip->source_max_current[i]);
+			}
+			break;
+		case DMT_REQUEST:
+			chip->send_head |= ((1 << 12) | (cmd & 0xf));
+			/* send request with FVRDO */
+			chip->send_load[0] = (chip->pos_power << 28) |
+					    (0 << 27) |
+					    (1 << 26) |
+					    (0 << 25) |
+					    (0 << 24);
+
+			switch (CAP_POWER_TYPE(chip->rec_load[chip->pos_power - 1])) {
+			case 0:
+				/* Fixed Supply */
+				chip->send_load[0] |= ((CAP_FPDO_VOLTAGE(chip->rec_load[chip->pos_power - 1]) << 10) & 0x3ff);
+				chip->send_load[0] |= (CAP_FPDO_CURRENT(chip->rec_load[chip->pos_power - 1]) & 0x3ff);
+				break;
+			case 1:
+				/* Battery */
+				chip->send_load[0] |= ((CAP_VPDO_VOLTAGE(chip->rec_load[chip->pos_power - 1]) << 10) & 0x3ff);
+				chip->send_load[0] |= (CAP_VPDO_CURRENT(chip->rec_load[chip->pos_power - 1]) & 0x3ff);
+				break;
+			default:
+				/* not meet battery caps */
+				break;
+			}
+			break;
+		case DMT_SINKCAPABILITIES:
+			break;
+		case DMT_VENDERDEFINED:
+			break;
+		default:
+			break;
 		}
 	} else {
-		if (chip->cc2 != cc_status) {
-			fusb302_log(chip, "cc2: %s -> %s",
-				    typec_cc_status_name[chip->cc2],
-				    typec_cc_status_name[cc_status]);
-			chip->cc2 = cc_status;
-			tcpm_cc_change(chip->tcpm_port);
-		}
+		chip->send_head |= (cmd & 0xf);
 	}
-
-done:
-	mutex_unlock(&chip->lock);
 }
 
-static void init_tcpc_dev(struct tcpc_dev *fusb302_tcpc_dev)
+/*
+ * This algorithm defaults to choosing higher pin config over lower ones in
+ * order to prefer multi-function if desired.
+ *
+ *  NAME | SIGNALING | OUTPUT TYPE | MULTI-FUNCTION | PIN CONFIG
+ * -------------------------------------------------------------
+ *  A    |  USB G2   |  ?          | no             | 00_0001
+ *  B    |  USB G2   |  ?          | yes            | 00_0010
+ *  C    |  DP       |  CONVERTED  | no             | 00_0100
+ *  D    |  PD       |  CONVERTED  | yes            | 00_1000
+ *  E    |  DP       |  DP         | no             | 01_0000
+ *  F    |  PD       |  DP         | yes            | 10_0000
+ *
+ * if UFP has NOT asserted multi-function preferred code masks away B/D/F
+ * leaving only A/C/E.  For single-output dongles that should leave only one
+ * possible pin config depending on whether its a converter DP->(VGA|HDMI) or DP
+ * output.  If UFP is a USB-C receptacle it may assert C/D/E/F.  The DFP USB-C
+ * receptacle must always choose C/D in those cases.
+ */
+static int pd_dfp_dp_get_pin_assignment(struct fusb30x_chip *chip,
+					uint32_t caps, uint32_t status)
 {
-	fusb302_tcpc_dev->init = tcpm_init;
-	fusb302_tcpc_dev->get_vbus = tcpm_get_vbus;
-	fusb302_tcpc_dev->get_current_limit = tcpm_get_current_limit;
-	fusb302_tcpc_dev->set_cc = tcpm_set_cc;
-	fusb302_tcpc_dev->get_cc = tcpm_get_cc;
-	fusb302_tcpc_dev->set_polarity = tcpm_set_polarity;
-	fusb302_tcpc_dev->set_vconn = tcpm_set_vconn;
-	fusb302_tcpc_dev->set_vbus = tcpm_set_vbus;
-	fusb302_tcpc_dev->set_pd_rx = tcpm_set_pd_rx;
-	fusb302_tcpc_dev->set_roles = tcpm_set_roles;
-	fusb302_tcpc_dev->start_toggling = tcpm_start_toggling;
-	fusb302_tcpc_dev->pd_transmit = tcpm_pd_transmit;
-}
+	uint32_t pin_caps;
 
-static const char * const cc_polarity_name[] = {
-	[TYPEC_POLARITY_CC1]	= "Polarity_CC1",
-	[TYPEC_POLARITY_CC2]	= "Polarity_CC2",
-};
+	/* revisit with DFP that can be a sink */
+	pin_caps = PD_DP_PIN_CAPS(caps);
 
-static int fusb302_set_cc_polarity_and_pull(struct fusb302_chip *chip,
-					    enum typec_cc_polarity cc_polarity,
-					    bool pull_up, bool pull_down)
-{
-	int ret = 0;
-	u8 switches0_data = 0x00;
-	u8 switches1_mask = FUSB_REG_SWITCHES1_TXCC1_EN |
-			    FUSB_REG_SWITCHES1_TXCC2_EN;
-	u8 switches1_data = 0x00;
-
-	if (pull_down)
-		switches0_data |= FUSB_REG_SWITCHES0_CC1_PD_EN |
-				  FUSB_REG_SWITCHES0_CC2_PD_EN;
-
-	if (cc_polarity == TYPEC_POLARITY_CC1) {
-		switches0_data |= FUSB_REG_SWITCHES0_MEAS_CC1;
-		if (chip->vconn_on)
-			switches0_data |= FUSB_REG_SWITCHES0_VCONN_CC2;
-		if (pull_up)
-			switches0_data |= FUSB_REG_SWITCHES0_CC1_PU_EN;
-		switches1_data = FUSB_REG_SWITCHES1_TXCC1_EN;
-	} else {
-		switches0_data |= FUSB_REG_SWITCHES0_MEAS_CC2;
-		if (chip->vconn_on)
-			switches0_data |= FUSB_REG_SWITCHES0_VCONN_CC1;
-		if (pull_up)
-			switches0_data |= FUSB_REG_SWITCHES0_CC2_PU_EN;
-		switches1_data = FUSB_REG_SWITCHES1_TXCC2_EN;
-	}
-	ret = fusb302_i2c_write(chip, FUSB_REG_SWITCHES0, switches0_data);
-	if (ret < 0)
-		return ret;
-	ret = fusb302_i2c_mask_write(chip, FUSB_REG_SWITCHES1,
-				     switches1_mask, switches1_data);
-	if (ret < 0)
-		return ret;
-	chip->cc_polarity = cc_polarity;
+	/* if don't want multi-function then ignore those pin configs */
+	if (!PD_VDO_DPSTS_MF_PREF(status))
+		pin_caps &= ~MODE_DP_PIN_MF_MASK;
 
-	return ret;
-}
+	/* revisit if DFP drives USB Gen 2 signals */
+	if (PD_DP_SIGNAL_GEN2(caps))
+		pin_caps &= ~MODE_DP_PIN_DP_MASK;
+	else
+		pin_caps &= ~MODE_DP_PIN_BR2_MASK;
 
-static int fusb302_handle_togdone_snk(struct fusb302_chip *chip,
-				      u8 togdone_result)
-{
-	int ret = 0;
-	u8 status0;
-	u8 bc_lvl;
-	enum typec_cc_polarity cc_polarity;
-	enum typec_cc_status cc_status_active, cc1, cc2;
+	/* if C/D present they have precedence over E/F for USB-C->USB-C */
+	if (pin_caps & (MODE_DP_PIN_C | MODE_DP_PIN_D))
+		pin_caps &= ~(MODE_DP_PIN_E | MODE_DP_PIN_F);
 
-	/* set polarity and pull_up, pull_down */
-	cc_polarity = (togdone_result == FUSB_REG_STATUS1A_TOGSS_SNK1) ?
-		      TYPEC_POLARITY_CC1 : TYPEC_POLARITY_CC2;
-	ret = fusb302_set_cc_polarity_and_pull(chip, cc_polarity, false, true);
-	if (ret < 0) {
-		fusb302_log(chip, "cannot set cc polarity %s, ret=%d",
-			    cc_polarity_name[cc_polarity], ret);
-		return ret;
-	}
-	/* fusb302_set_cc_polarity() has set the correct measure block */
-	ret = fusb302_i2c_read(chip, FUSB_REG_STATUS0, &status0);
-	if (ret < 0)
-		return ret;
-	bc_lvl = status0 & FUSB_REG_STATUS0_BC_LVL_MASK;
-	cc_status_active = fusb302_bc_lvl_to_cc(bc_lvl);
-	/* restart toggling if the cc status on the active line is OPEN */
-	if (cc_status_active == TYPEC_CC_OPEN) {
-		fusb302_log(chip, "restart toggling as CC_OPEN detected");
-		ret = fusb302_set_toggling(chip, chip->toggling_mode);
-		return ret;
-	}
-	/* update tcpm with the new cc value */
-	cc1 = (cc_polarity == TYPEC_POLARITY_CC1) ?
-	      cc_status_active : TYPEC_CC_OPEN;
-	cc2 = (cc_polarity == TYPEC_POLARITY_CC2) ?
-	      cc_status_active : TYPEC_CC_OPEN;
-	if ((chip->cc1 != cc1) || (chip->cc2 != cc2)) {
-		chip->cc1 = cc1;
-		chip->cc2 = cc2;
-		tcpm_cc_change(chip->tcpm_port);
-	}
-	/* turn off toggling */
-	ret = fusb302_set_toggling(chip, TOGGLING_MODE_OFF);
-	if (ret < 0) {
-		fusb302_log(chip,
-			    "cannot set toggling mode off, ret=%d", ret);
-		return ret;
-	}
-	/* unmask bc_lvl interrupt */
-	ret = fusb302_i2c_clear_bits(chip, FUSB_REG_MASK, FUSB_REG_MASK_BC_LVL);
-	if (ret < 0) {
-		fusb302_log(chip,
-			    "cannot unmask bc_lcl interrupt, ret=%d", ret);
-		return ret;
-	}
-	chip->intr_bc_lvl = true;
-	fusb302_log(chip, "detected cc1=%s, cc2=%s",
-		    typec_cc_status_name[cc1],
-		    typec_cc_status_name[cc2]);
+	/* returns undefined for zero */
+	if (!pin_caps)
+		return 0;
 
-	return ret;
+	/* choosing higher pin config over lower ones */
+	return 1 << (31 - __builtin_clz(pin_caps));
 }
 
-/* On error returns < 0, otherwise a typec_cc_status value */
-static int fusb302_get_src_cc_status(struct fusb302_chip *chip,
-				     enum typec_cc_polarity cc_polarity,
-				     enum typec_cc_status *cc)
+static void set_vdm_mesg(struct fusb30x_chip *chip, int cmd, int type, int mode)
 {
-	u8 ra_mda = ra_mda_value[chip->src_current_status];
-	u8 rd_mda = rd_mda_value[chip->src_current_status];
-	u8 switches0_data, status0;
-	int ret;
+	chip->send_head = (chip->msg_id & 0x7) << 9;
+	chip->send_head |= (chip->notify.power_role & 0x1) << 8;
+
+	chip->send_head = ((chip->msg_id & 0x7) << 9) |
+			 ((chip->notify.power_role & 0x1) << 8) |
+			 (1 << 6) |
+			 ((chip->notify.data_role & 0x1) << 5) |
+			 (DMT_VENDERDEFINED & 0xf);
+
+	chip->send_load[0] = (1 << 15) |
+			    (0 << 13) |
+			    (type << 6) |
+			    (cmd);
+
+	switch (cmd) {
+	case VDM_DISCOVERY_ID:
+	case VDM_DISCOVERY_SVIDS:
+	case VDM_ATTENTION:
+		chip->send_load[0] |= (0xff00 << 16);
+		chip->send_head |= (1 << 12);
+		break;
+	case VDM_DISCOVERY_MODES:
+		chip->send_load[0] |=
+			(chip->vdm_svid[chip->val_tmp >> 1] << 16);
+		chip->send_head |= (1 << 12);
+		break;
+	case VDM_ENTER_MODE:
+		chip->send_head |= (1 << 12);
+		chip->send_load[0] |= (mode << 8) | (0xff01 << 16);
+		break;
+	case VDM_EXIT_MODE:
+		chip->send_head |= (1 << 12);
+		chip->send_load[0] |= (0x0f << 8) | (0xff01 << 16);
+		break;
+	case VDM_DP_STATUS_UPDATE:
+		chip->send_head |= (2 << 12);
+		chip->send_load[0] |= (1 << 8) | (0xff01 << 16);
+		chip->send_load[1] = 5;
+		break;
+	case VDM_DP_CONFIG:
+		chip->send_head |= (2 << 12);
+		chip->send_load[0] |= (1 << 8) | (0xff01 << 16);
+
+		chip->notify.pin_assignment_def =
+			pd_dfp_dp_get_pin_assignment(chip, chip->notify.dp_caps,
+						     chip->notify.dp_status);
+
+		chip->send_load[1] = (chip->notify.pin_assignment_def << 8) |
+				    (1 << 2) | 2;
+		dev_dbg(chip->dev, "DisplayPort Configurations: 0x%08x\n",
+			chip->send_load[1]);
+		break;
+	default:
+		break;
+	}
+}
+
+static enum tx_state policy_send_hardrst(struct fusb30x_chip *chip, u32 evt)
+{
+	switch (chip->tx_state) {
+	case 0:
+		regmap_update_bits(chip->regmap, FUSB_REG_CONTROL3,
+				   CONTROL3_SEND_HARDRESET,
+				   CONTROL3_SEND_HARDRESET);
+		chip->tx_state = tx_busy;
+		chip->timer_state = T_BMC_TIMEOUT;
+		fusb_timer_start(&chip->timer_state_machine,
+				 chip->timer_state);
+		break;
+	default:
+		if (evt & EVENT_TIMER_STATE)
+			chip->tx_state = tx_success;
+		break;
+	}
+	return chip->tx_state;
+}
+
+static enum tx_state policy_send_data(struct fusb30x_chip *chip)
+{
+	u8 senddata[40];
+	int pos = 0;
+	u8 len;
+
+	switch (chip->tx_state) {
+	case 0:
+		senddata[pos++] = FUSB_TKN_SYNC1;
+		senddata[pos++] = FUSB_TKN_SYNC1;
+		senddata[pos++] = FUSB_TKN_SYNC1;
+		senddata[pos++] = FUSB_TKN_SYNC2;
+
+		len = PD_HEADER_CNT(chip->send_head) << 2;
+		senddata[pos++] = FUSB_TKN_PACKSYM | ((len + 2) & 0x1f);
+
+		senddata[pos++] = chip->send_head & 0xff;
+		senddata[pos++] = (chip->send_head >> 8) & 0xff;
+
+		memcpy(&senddata[pos], chip->send_load, len);
+		pos += len;
+
+		senddata[pos++] = FUSB_TKN_JAMCRC;
+		senddata[pos++] = FUSB_TKN_EOP;
+		senddata[pos++] = FUSB_TKN_TXOFF;
+		senddata[pos++] = FUSB_TKN_TXON;
+
+		regmap_raw_write(chip->regmap, FUSB_REG_FIFO, senddata, pos);
+		chip->tx_state = tx_busy;
+		break;
+
+	default:
+		/* wait Tx result */
+		break;
+	}
+
+	return chip->tx_state;
+}
+
+static void process_vdm_msg(struct fusb30x_chip *chip)
+{
+	u32 vdm_header = chip->rec_load[0];
+	int i;
+	u32 tmp;
+
+	/* can't procee unstructed vdm msg */
+	if (!GET_VDMHEAD_STRUCT_TYPE(vdm_header)) {
+		dev_warn(chip->dev, "unknown unstructed vdm message\n");
+		return;
+	}
+
+	switch (GET_VDMHEAD_CMD_TYPE(vdm_header)) {
+	case VDM_TYPE_INIT:
+		switch (GET_VDMHEAD_CMD(vdm_header)) {
+		case VDM_ATTENTION:
+			chip->notify.dp_status = GET_DP_STATUS(chip->rec_load[1]);
+			dev_info(chip->dev, "attention, dp_status %x\n",
+				 chip->rec_load[1]);
+			chip->notify.attention = true;
+			platform_fusb_notify(chip);
+			break;
+		default:
+			dev_warn(chip->dev, "rec unknown init vdm msg\n");
+			break;
+		}
+		break;
+	case VDM_TYPE_ACK:
+		switch (GET_VDMHEAD_CMD(vdm_header)) {
+		case VDM_DISCOVERY_ID:
+			chip->vdm_id = chip->rec_load[1];
+			break;
+		case VDM_DISCOVERY_SVIDS:
+			for (i = 0; i < 6; i++) {
+				tmp = (chip->rec_load[i + 1] >> 16) &
+				      0x0000ffff;
+				if (tmp) {
+					chip->vdm_svid[i * 2] = tmp;
+					chip->vdm_svid_num++;
+				} else {
+					break;
+				}
+
+				tmp = (chip->rec_load[i + 1] & 0x0000ffff);
+				if (tmp) {
+					chip->vdm_svid[i * 2 + 1] = tmp;
+					chip->vdm_svid_num++;
+				} else {
+					break;
+				}
+			}
+			break;
+		case VDM_DISCOVERY_MODES:
+			/* indicate there are some vdo modes */
+			if (PD_HEADER_CNT(chip->rec_head) > 1) {
+				/*
+				 * store mode config,
+				 * enter first mode default
+				 */
+				tmp = chip->rec_load[1];
+
+				if ((!((tmp >> 8) & 0x3f)) &&
+				    (!((tmp >> 16) & 0x3f))) {
+					chip->val_tmp |= 1;
+					break;
+				}
+				chip->notify.dp_caps = chip->rec_load[1];
+				chip->notify.pin_assignment_def = 0;
+				chip->notify.pin_assignment_support =
+							PD_DP_PIN_CAPS(tmp);
+				chip->val_tmp |= 1;
+				dev_dbg(chip->dev,
+					"DisplayPort Capabilities: 0x%08x\n",
+					chip->rec_load[1]);
+			}
+			break;
+		case VDM_ENTER_MODE:
+			chip->val_tmp = 1;
+			break;
+		case VDM_DP_STATUS_UPDATE:
+			chip->notify.dp_status = GET_DP_STATUS(chip->rec_load[1]);
+			dev_dbg(chip->dev, "DisplayPort Status: 0x%08x\n",
+				chip->rec_load[1]);
+			chip->val_tmp = 1;
+			break;
+		case VDM_DP_CONFIG:
+			chip->val_tmp = 1;
+			dev_info(chip->dev,
+				 "DP config successful, pin_assignment 0x%x\n",
+				 chip->notify.pin_assignment_def);
+			chip->notify.is_enter_mode = true;
+			break;
+		default:
+			break;
+		}
+		break;
+	case VDM_TYPE_NACK:
+			dev_warn(chip->dev, "REC NACK for 0x%x\n",
+				 GET_VDMHEAD_CMD(vdm_header));
+			/* disable vdm */
+			chip->vdm_state = VDM_STATE_ERR;
+		break;
+	}
+}
+
+static int vdm_send_discoveryid(struct fusb30x_chip *chip, u32 evt)
+{
+	int tmp;
+
+	switch (chip->vdm_send_state) {
+	case 0:
+		set_vdm_mesg(chip, VDM_DISCOVERY_ID, VDM_TYPE_INIT, 0);
+		chip->vdm_id = 0;
+		chip->tx_state = 0;
+		chip->vdm_send_state++;
+	case 1:
+		tmp = policy_send_data(chip);
+		if (tmp == tx_success) {
+			chip->vdm_send_state++;
+			chip->timer_state = T_SENDER_RESPONSE;
+			fusb_timer_start(&chip->timer_state_machine,
+					 chip->timer_state);
+		} else if (tmp == tx_failed) {
+			dev_warn(chip->dev, "VDM_DISCOVERY_ID send failed\n");
+			/* disable auto_vdm_machine */
+			chip->vdm_state = VDM_STATE_ERR;
+			return -EPIPE;
+		}
+
+		if (chip->vdm_send_state != 2)
+			break;
+	default:
+		if (chip->vdm_id) {
+			chip->vdm_send_state = 0;
+			return 0;
+		} else if (evt & EVENT_TIMER_STATE) {
+			dev_warn(chip->dev, "VDM_DISCOVERY_ID time out\n");
+			chip->vdm_state = VDM_STATE_ERR;
+			chip->work_continue |= EVENT_WORK_CONTINUE;
+			return -ETIMEDOUT;
+		}
+		break;
+	}
+	return -EINPROGRESS;
+}
+
+static int vdm_send_discoverysvid(struct fusb30x_chip *chip, u32 evt)
+{
+	int tmp;
+
+	switch (chip->vdm_send_state) {
+	case 0:
+		set_vdm_mesg(chip, VDM_DISCOVERY_SVIDS, VDM_TYPE_INIT, 0);
+		memset(chip->vdm_svid, 0, sizeof(chip->vdm_svid));
+		chip->vdm_svid_num = 0;
+		chip->tx_state = 0;
+		chip->vdm_send_state++;
+	case 1:
+		tmp = policy_send_data(chip);
+		if (tmp == tx_success) {
+			chip->vdm_send_state++;
+			chip->timer_state = T_SENDER_RESPONSE;
+			fusb_timer_start(&chip->timer_state_machine,
+					 chip->timer_state);
+		} else if (tmp == tx_failed) {
+			dev_warn(chip->dev, "VDM_DISCOVERY_SVIDS send failed\n");
+			/* disable auto_vdm_machine */
+			chip->vdm_state = VDM_STATE_ERR;
+			return -EPIPE;
+		}
+
+		if (chip->vdm_send_state != 2)
+			break;
+	default:
+		if (chip->vdm_svid_num) {
+			chip->vdm_send_state = 0;
+			return 0;
+		} else if (evt & EVENT_TIMER_STATE) {
+			dev_warn(chip->dev, "VDM_DISCOVERY_SVIDS time out\n");
+			chip->vdm_state = VDM_STATE_ERR;
+			chip->work_continue |= EVENT_WORK_CONTINUE;
+			return -ETIMEDOUT;
+		}
+		break;
+	}
+	return -EINPROGRESS;
+}
+
+static int vdm_send_discoverymodes(struct fusb30x_chip *chip, u32 evt)
+{
+	int tmp;
+
+	if ((chip->val_tmp >> 1) != chip->vdm_svid_num) {
+		switch (chip->vdm_send_state) {
+		case 0:
+			set_vdm_mesg(chip, VDM_DISCOVERY_MODES,
+				     VDM_TYPE_INIT, 0);
+			chip->tx_state = 0;
+			chip->vdm_send_state++;
+		case 1:
+			tmp = policy_send_data(chip);
+			if (tmp == tx_success) {
+				chip->vdm_send_state++;
+				chip->timer_state = T_SENDER_RESPONSE;
+				fusb_timer_start(&chip->timer_state_machine,
+						 chip->timer_state);
+			} else if (tmp == tx_failed) {
+				dev_warn(chip->dev,
+					 "VDM_DISCOVERY_MODES send failed\n");
+				chip->vdm_state = VDM_STATE_ERR;
+				return -EPIPE;
+			}
+
+			if (chip->vdm_send_state != 2)
+				break;
+		default:
+			if (chip->val_tmp & 1) {
+				chip->val_tmp &= 0xfe;
+				chip->val_tmp += 2;
+				chip->vdm_send_state = 0;
+				chip->work_continue |= EVENT_WORK_CONTINUE;
+			} else if (evt & EVENT_TIMER_STATE) {
+				dev_warn(chip->dev,
+					 "VDM_DISCOVERY_MODES time out\n");
+				chip->vdm_state = VDM_STATE_ERR;
+				chip->work_continue |= EVENT_WORK_CONTINUE;
+				return -ETIMEDOUT;
+			}
+			break;
+		}
+	} else {
+		chip->val_tmp = 0;
+		return 0;
+	}
+
+	return -EINPROGRESS;
+}
+
+static int vdm_send_entermode(struct fusb30x_chip *chip, u32 evt)
+{
+	int tmp;
+
+	switch (chip->vdm_send_state) {
+	case 0:
+		set_vdm_mesg(chip, VDM_ENTER_MODE, VDM_TYPE_INIT, 1);
+		chip->tx_state = 0;
+		chip->vdm_send_state++;
+		chip->notify.is_enter_mode = false;
+	case 1:
+		tmp = policy_send_data(chip);
+		if (tmp == tx_success) {
+			chip->vdm_send_state++;
+			chip->timer_state = T_SENDER_RESPONSE;
+			fusb_timer_start(&chip->timer_state_machine,
+					 chip->timer_state);
+		} else if (tmp == tx_failed) {
+			dev_warn(chip->dev, "VDM_ENTER_MODE send failed\n");
+			/* disable auto_vdm_machine */
+			chip->vdm_state = VDM_STATE_ERR;
+			return -EPIPE;
+		}
+
+		if (chip->vdm_send_state != 2)
+			break;
+	default:
+		if (chip->val_tmp) {
+			chip->val_tmp = 0;
+			chip->vdm_send_state = 0;
+			return 0;
+		} else if (evt & EVENT_TIMER_STATE) {
+			dev_warn(chip->dev, "VDM_ENTER_MODE time out\n");
+			chip->vdm_state = VDM_STATE_ERR;
+			chip->work_continue |= EVENT_WORK_CONTINUE;
+			return -ETIMEDOUT;
+		}
+		break;
+	}
+	return -EINPROGRESS;
+}
+
+static int vdm_send_getdpstatus(struct fusb30x_chip *chip, u32 evt)
+{
+	int tmp;
+
+	switch (chip->vdm_send_state) {
+	case 0:
+		set_vdm_mesg(chip, VDM_DP_STATUS_UPDATE, VDM_TYPE_INIT, 1);
+		chip->tx_state = 0;
+		chip->vdm_send_state++;
+	case 1:
+		tmp = policy_send_data(chip);
+		if (tmp == tx_success) {
+			chip->vdm_send_state++;
+			chip->timer_state = T_SENDER_RESPONSE;
+			fusb_timer_start(&chip->timer_state_machine,
+					 chip->timer_state);
+		} else if (tmp == tx_failed) {
+			dev_warn(chip->dev,
+				 "VDM_DP_STATUS_UPDATE send failed\n");
+			/* disable auto_vdm_machine */
+			chip->vdm_state = VDM_STATE_ERR;
+			return -EPIPE;
+		}
+
+		if (chip->vdm_send_state != 2)
+			break;
+	default:
+		if (chip->val_tmp) {
+			chip->val_tmp = 0;
+			chip->vdm_send_state = 0;
+			return 0;
+		} else if (evt & EVENT_TIMER_STATE) {
+			dev_warn(chip->dev, "VDM_DP_STATUS_UPDATE time out\n");
+			chip->vdm_state = VDM_STATE_ERR;
+			chip->work_continue |= EVENT_WORK_CONTINUE;
+			return -ETIMEDOUT;
+		}
+		break;
+	}
+	return -EINPROGRESS;
+}
+
+static int vdm_send_dpconfig(struct fusb30x_chip *chip, u32 evt)
+{
+	int tmp;
+
+	switch (chip->vdm_send_state) {
+	case 0:
+		set_vdm_mesg(chip, VDM_DP_CONFIG, VDM_TYPE_INIT, 0);
+		chip->tx_state = 0;
+		chip->vdm_send_state++;
+	case 1:
+		tmp = policy_send_data(chip);
+		if (tmp == tx_success) {
+			chip->vdm_send_state++;
+			chip->timer_state = T_SENDER_RESPONSE;
+			fusb_timer_start(&chip->timer_state_machine,
+					 chip->timer_state);
+		} else if (tmp == tx_failed) {
+			dev_warn(chip->dev, "vdm_send_dpconfig send failed\n");
+			/* disable auto_vdm_machine */
+			chip->vdm_state = VDM_STATE_ERR;
+			return -EPIPE;
+		}
+
+		if (chip->vdm_send_state != 2)
+			break;
+	default:
+		if (chip->val_tmp) {
+			chip->val_tmp = 0;
+			chip->vdm_send_state = 0;
+			return 0;
+		} else if (evt & EVENT_TIMER_STATE) {
+			dev_warn(chip->dev, "vdm_send_dpconfig time out\n");
+			chip->vdm_state = VDM_STATE_ERR;
+			chip->work_continue |= EVENT_WORK_CONTINUE;
+			return -ETIMEDOUT;
+		}
+		break;
+	}
+	return -EINPROGRESS;
+}
+
+/* without break if success */
+#define AUTO_VDM_HANDLE(func, chip, evt, conditions) \
+do { \
+	conditions = func(chip, evt); \
+	if (!conditions) { \
+		chip->vdm_state++; \
+		chip->work_continue |= EVENT_WORK_CONTINUE; \
+	} else { \
+		if (conditions != -EINPROGRESS) \
+			chip->vdm_state = VDM_STATE_ERR; \
+	} \
+} while (0)
+
+static void auto_vdm_machine(struct fusb30x_chip *chip, u32 evt)
+{
+	int conditions;
+
+	switch (chip->vdm_state) {
+	case VDM_STATE_DISCOVERY_ID:
+		AUTO_VDM_HANDLE(vdm_send_discoveryid, chip, evt, conditions);
+		break;
+	case VDM_STATE_DISCOVERY_SVID:
+		AUTO_VDM_HANDLE(vdm_send_discoverysvid, chip, evt, conditions);
+		break;
+	case VDM_STATE_DISCOVERY_MODES:
+		AUTO_VDM_HANDLE(vdm_send_discoverymodes, chip, evt, conditions);
+		break;
+	case VDM_STATE_ENTER_MODE:
+		AUTO_VDM_HANDLE(vdm_send_entermode, chip, evt, conditions);
+		break;
+	case VDM_STATE_UPDATE_STATUS:
+		AUTO_VDM_HANDLE(vdm_send_getdpstatus, chip, evt, conditions);
+		break;
+	case VDM_STATE_DP_CONFIG:
+		AUTO_VDM_HANDLE(vdm_send_dpconfig, chip, evt, conditions);
+		break;
+	case VDM_STATE_NOTIFY:
+		platform_fusb_notify(chip);
+		chip->vdm_state = VDM_STATE_READY;
+		break;
+	default:
+		break;
+	}
+}
+
+static void fusb_state_disabled(struct fusb30x_chip *chip, u32 evt)
+{
+	/* Do nothing */
+}
+
+static void fusb_state_unattached(struct fusb30x_chip *chip, u32 evt)
+{
+	chip->notify.is_cc_connected = false;
+	chip->is_pd_support = false;
+
+	if ((evt & EVENT_CC) && chip->cc_state) {
+		if (chip->cc_state & CC_STATE_TOGSS_IS_UFP)
+			set_state(chip, attach_wait_sink);
+		else
+			set_state(chip, attach_wait_source);
+
+		chip->vbus_begin = tcpm_check_vbus(chip);
+
+		tcpm_set_polarity(chip, (chip->cc_state & CC_STATE_TOGSS_CC1) ?
+					TYPEC_POLARITY_CC1 :
+					TYPEC_POLARITY_CC2);
+		tcpm_get_cc(chip, &chip->cc1, &chip->cc2);
+		chip->debounce_cnt = 0;
+		chip->timer_mux = 2;
+		fusb_timer_start(&chip->timer_mux_machine, chip->timer_mux);
+	}
+}
+
+static void fusb_state_try_attach_set(struct fusb30x_chip *chip,
+				      enum role_mode mode)
+{
+	if (mode == ROLE_MODE_NONE || mode == ROLE_MODE_DRP ||
+	    mode == ROLE_MODE_ASS)
+		return;
+
+	tcpm_init(chip);
+	tcpm_set_cc(chip, (mode == ROLE_MODE_DFP) ?
+			  ROLE_MODE_DFP : ROLE_MODE_UFP);
+	chip->timer_mux = T_PD_TRY_DRP;
+	fusb_timer_start(&chip->timer_mux_machine, chip->timer_mux);
+	set_state(chip, (mode == ROLE_MODE_DFP) ?
+			attach_try_src : attach_try_snk);
+}
+
+static void fusb_state_attach_wait_sink(struct fusb30x_chip *chip, u32 evt)
+{
+	int cc1, cc2;
+
+	if (evt & EVENT_TIMER_MUX) {
+		if (tcpm_check_vbus(chip)) {
+			chip->timer_mux = T_DISABLED;
+			if (chip->role == ROLE_MODE_DRP &&
+			    chip->try_role == ROLE_MODE_DFP &&
+			    !chip->try_role_complete) {
+				fusb_state_try_attach_set(chip, ROLE_MODE_DFP);
+				return;
+			} else if (chip->try_role_complete) {
+				chip->timer_mux = T_PD_SOURCE_ON;
+				fusb_timer_start(&chip->timer_mux_machine,
+						 chip->timer_mux);
+				set_state(chip, attached_sink);
+				return;
+			}
+		}
+
+		tcpm_get_cc(chip, &cc1, &cc2);
+
+		if ((chip->cc1 == cc1) && (chip->cc2 == cc2)) {
+			chip->debounce_cnt++;
+		} else {
+			chip->cc1 = cc1;
+			chip->cc2 = cc2;
+			chip->debounce_cnt = 0;
+		}
+
+		if (chip->debounce_cnt > N_DEBOUNCE_CNT) {
+			chip->timer_mux = T_DISABLED;
+			if ((chip->cc1 == TYPEC_CC_VOLT_RP &&
+			     chip->cc2 == TYPEC_CC_VOLT_OPEN) ||
+			    (chip->cc2 == TYPEC_CC_VOLT_RP &&
+			     chip->cc1 == TYPEC_CC_VOLT_OPEN)) {
+				chip->timer_mux = T_PD_SOURCE_ON;
+				fusb_timer_start(&chip->timer_mux_machine,
+						 chip->timer_mux);
+				set_state(chip, attached_sink);
+			} else {
+				set_state_unattached(chip);
+			}
+			return;
+		}
+
+		chip->timer_mux = 2;
+		fusb_timer_start(&chip->timer_mux_machine,
+				 chip->timer_mux);
+	}
+}
+
+static void fusb_state_attach_wait_source(struct fusb30x_chip *chip, u32 evt)
+{
+	int cc1, cc2;
+
+	if (evt & EVENT_TIMER_MUX) {
+		tcpm_get_cc(chip, &cc1, &cc2);
+
+		if ((chip->cc1 == cc1) && (chip->cc2 == cc2)) {
+			chip->debounce_cnt++;
+		} else {
+			chip->cc1 = cc1;
+			chip->cc2 = cc2;
+			chip->debounce_cnt = 0;
+		}
+
+		if (chip->debounce_cnt > N_DEBOUNCE_CNT) {
+			if (((!chip->cc1) || (!chip->cc2)) &&
+			    ((chip->cc1 == TYPEC_CC_VOLT_RD) ||
+			     (chip->cc2 == TYPEC_CC_VOLT_RD))) {
+				if (chip->role == ROLE_MODE_DRP &&
+				    chip->try_role == ROLE_MODE_UFP &&
+				    !chip->try_role_complete)
+					fusb_state_try_attach_set(chip,
+							ROLE_MODE_UFP);
+				else
+					set_state(chip, attached_source);
+			} else {
+				set_state_unattached(chip);
+			}
+			return;
+		}
+
+		chip->timer_mux = 2;
+		fusb_timer_start(&chip->timer_mux_machine,
+				 chip->timer_mux);
+	}
+}
+
+static void fusb_state_attached_source(struct fusb30x_chip *chip, u32 evt)
+{
+	platform_set_vbus_lvl_enable(chip, 1, 0);
+	tcpm_set_polarity(chip, (chip->cc_state & CC_STATE_TOGSS_CC1) ?
+				TYPEC_POLARITY_CC1 : TYPEC_POLARITY_CC2);
+	tcpm_set_vconn(chip, 1);
+
+	chip->notify.is_cc_connected = true;
+
+	chip->notify.power_role = POWER_ROLE_SOURCE;
+	chip->notify.data_role = DATA_ROLE_DFP;
+	chip->hardrst_count = 0;
+	set_state(chip, policy_src_startup);
+	regmap_update_bits(chip->regmap, FUSB_REG_MASK, MASK_M_COMP_CHNG, 0);
+	dev_info(chip->dev, "CC connected in %s as DFP\n",
+		 chip->cc_polarity ? "CC1" : "CC2");
+	usb_role_switch_set_role(chip->role_sw, USB_ROLE_HOST);
+}
+
+static void fusb_state_attached_sink(struct fusb30x_chip *chip, u32 evt)
+{
+	if (tcpm_check_vbus(chip)) {
+		chip->timer_mux = T_DISABLED;
+		chip->timer_state = T_DISABLED;
+		if (!chip->try_role_complete &&
+		    chip->try_role == ROLE_MODE_DFP &&
+		    chip->role == ROLE_MODE_DRP) {
+			fusb_state_try_attach_set(chip, ROLE_MODE_DFP);
+			return;
+		}
+
+		chip->try_role_complete = true;
+		chip->notify.is_cc_connected = true;
+		chip->notify.power_role = POWER_ROLE_SINK;
+		chip->notify.data_role = DATA_ROLE_UFP;
+		chip->hardrst_count = 0;
+		set_state(chip, policy_snk_startup);
+		dev_info(chip->dev, "CC connected in %s as UFP\n",
+			 chip->cc_polarity ? "CC1" : "CC2");
+		usb_role_switch_set_role(chip->role_sw, USB_ROLE_DEVICE);
+		return;
+	} else if (evt & EVENT_TIMER_MUX) {
+		set_state_unattached(chip);
+		return;
+	}
+
+	chip->timer_state = 2;
+	fusb_timer_start(&chip->timer_state_machine,
+			 chip->timer_state);
+}
+
+static void fusb_state_try_attach(struct fusb30x_chip *chip, u32 evt,
+				  enum role_mode mode)
+{
+	if ((evt & EVENT_CC) && chip->cc_state) {
+		chip->try_role_complete = true;
+		if (chip->cc_state & CC_STATE_TOGSS_IS_UFP)
+			set_state(chip, (mode == ROLE_MODE_UFP) ?
+					attach_wait_sink : error_recovery);
+		else
+			set_state(chip, (mode == ROLE_MODE_DFP) ?
+					attach_wait_source : error_recovery);
+
+		tcpm_set_polarity(chip, (chip->cc_state & CC_STATE_TOGSS_CC1) ?
+					TYPEC_POLARITY_CC1 :
+					TYPEC_POLARITY_CC2);
+		tcpm_get_cc(chip, &chip->cc1, &chip->cc2);
+		chip->debounce_cnt = 0;
+		chip->timer_mux = 2;
+		fusb_timer_start(&chip->timer_mux_machine, chip->timer_mux);
+	} else if (evt & EVENT_TIMER_MUX) {
+		if (!chip->try_role_complete) {
+			chip->try_role_complete = true;
+			fusb_state_try_attach_set(chip,
+						  (mode == ROLE_MODE_DFP) ?
+						  ROLE_MODE_UFP :
+						  ROLE_MODE_DFP);
+		} else {
+			set_state(chip, error_recovery);
+		}
+	}
+}
+
+static void fusb_soft_reset_parameter(struct fusb30x_chip *chip)
+{
+	chip->caps_counter = 0;
+	chip->msg_id = 0;
+	chip->vdm_state = VDM_STATE_DISCOVERY_ID;
+	chip->vdm_substate = 0;
+	chip->vdm_send_state = 0;
+	chip->val_tmp = 0;
+	chip->pos_power = 0;
+}
+
+static void fusb_state_src_startup(struct fusb30x_chip *chip, u32 evt)
+{
+	chip->notify.is_pd_connected = false;
+	fusb_soft_reset_parameter(chip);
+
+	memset(chip->partner_cap, 0, sizeof(chip->partner_cap));
+
+	tcpm_set_msg_header(chip);
+	tcpm_set_polarity(chip, chip->cc_polarity);
+	tcpm_set_rx_enable(chip, 1);
+
+	set_state(chip, policy_src_send_caps);
+	platform_fusb_notify(chip);
+}
+
+static void fusb_state_src_discovery(struct fusb30x_chip *chip, u32 evt)
+{
+	switch (chip->sub_state) {
+	case 0:
+		chip->caps_counter++;
+
+		if (chip->caps_counter < N_CAPS_COUNT) {
+			chip->timer_state = T_TYPEC_SEND_SOURCECAP;
+			fusb_timer_start(&chip->timer_state_machine,
+					 chip->timer_state);
+			chip->sub_state = 1;
+		} else {
+			set_state(chip, disabled);
+		}
+		break;
+	default:
+		if (evt & EVENT_TIMER_STATE) {
+			set_state(chip, policy_src_send_caps);
+		} else if (evt & EVENT_TIMER_MUX) {
+			if (!chip->is_pd_support)
+				set_state(chip, disabled);
+			else if (chip->hardrst_count > N_HARDRESET_COUNT)
+				set_state(chip, error_recovery);
+			else
+				set_state(chip, policy_src_send_hardrst);
+		}
+		break;
+	}
+}
+
+static void fusb_state_src_send_caps(struct fusb30x_chip *chip, u32 evt)
+{
+	u32 tmp;
+
+	switch (chip->sub_state) {
+	case 0:
+		set_mesg(chip, DMT_SOURCECAPABILITIES, DATAMESSAGE);
+		chip->sub_state = 1;
+		chip->tx_state = tx_idle;
+		/* without break */
+	case 1:
+		tmp = policy_send_data(chip);
+
+		if (tmp == tx_success) {
+			chip->hardrst_count = 0;
+			chip->caps_counter = 0;
+			chip->timer_state = T_SENDER_RESPONSE;
+			fusb_timer_start(&chip->timer_state_machine,
+					 chip->timer_state);
+			chip->timer_mux = T_DISABLED;
+			chip->sub_state++;
+			chip->is_pd_support = true;
+		} else if (tmp == tx_failed) {
+			set_state(chip, policy_src_discovery);
+			break;
+		}
+
+		if (!(evt & FLAG_EVENT))
+			break;
+	default:
+		if (evt & EVENT_RX) {
+			if (PACKET_IS_DATA_MSG(chip->rec_head, DMT_REQUEST)) {
+				set_state(chip, policy_src_negotiate_cap);
+			} else {
+				set_state(chip, policy_src_send_softrst);
+			}
+		} else if (evt & EVENT_TIMER_STATE) {
+			if (chip->hardrst_count <= N_HARDRESET_COUNT)
+				set_state(chip, policy_src_send_hardrst);
+			else
+				set_state(chip, disabled);
+		} else if (evt & EVENT_TIMER_MUX) {
+			if (!chip->is_pd_support)
+				set_state(chip, disabled);
+			else if (chip->hardrst_count > N_HARDRESET_COUNT)
+				set_state(chip, error_recovery);
+			else
+				set_state(chip, policy_src_send_hardrst);
+		}
+		break;
+	}
+}
+
+static void fusb_state_src_negotiate_cap(struct fusb30x_chip *chip, u32 evt)
+{
+	u32 tmp;
+
+	/* base on evb1 */
+	tmp = (chip->rec_load[0] >> 28) & 0x07;
+	if (tmp > chip->n_caps_used)
+		set_state(chip, policy_src_cap_response);
+	else
+		set_state(chip, policy_src_transition_supply);
+}
+
+static void fusb_state_src_transition_supply(struct fusb30x_chip *chip,
+					     u32 evt)
+{
+	u32 tmp;
+
+	switch (chip->sub_state) {
+	case 0:
+		set_mesg(chip, CMT_ACCEPT, CONTROLMESSAGE);
+		chip->tx_state = tx_idle;
+		chip->sub_state++;
+		/* without break */
+	case 1:
+		tmp = policy_send_data(chip);
+		if (tmp == tx_success) {
+			chip->timer_state = T_SRC_TRANSITION;
+			chip->sub_state++;
+			fusb_timer_start(&chip->timer_state_machine,
+					 chip->timer_state);
+		} else if (tmp == tx_failed) {
+			set_state(chip, policy_src_send_softrst);
+		}
+		break;
+	case 2:
+		if (evt & EVENT_TIMER_STATE) {
+			chip->notify.is_pd_connected = true;
+			platform_set_vbus_lvl_enable(chip, 1, 0);
+			set_mesg(chip, CMT_PS_RDY, CONTROLMESSAGE);
+			chip->tx_state = tx_idle;
+			chip->sub_state++;
+			chip->work_continue |= EVENT_WORK_CONTINUE;
+		}
+		break;
+	default:
+		tmp = policy_send_data(chip);
+		if (tmp == tx_success) {
+			dev_info(chip->dev,
+				 "PD connected as DFP, supporting 5V\n");
+			set_state(chip, policy_src_ready);
+		} else if (tmp == tx_failed) {
+			set_state(chip, policy_src_send_softrst);
+		}
+		break;
+	}
+}
+
+static void fusb_state_src_cap_response(struct fusb30x_chip *chip, u32 evt)
+{
+	u32 tmp;
+
+	switch (chip->sub_state) {
+	case 0:
+		set_mesg(chip, CMT_REJECT, CONTROLMESSAGE);
+		chip->tx_state = tx_idle;
+		chip->sub_state++;
+		/* without break */
+	default:
+		tmp = policy_send_data(chip);
+		if (tmp == tx_success) {
+			if (chip->notify.is_pd_connected) {
+				dev_info(chip->dev,
+					 "PD connected as DFP, supporting 5V\n");
+				set_state(chip, policy_src_ready);
+			} else {
+				set_state(chip, policy_src_send_hardrst);
+			}
+		} else if (tmp == tx_failed) {
+			set_state(chip, policy_src_send_softrst);
+		}
+		break;
+	}
+}
+
+static void fusb_state_src_transition_default(struct fusb30x_chip *chip,
+					      u32 evt)
+{
+	switch (chip->sub_state) {
+	case 0:
+		chip->notify.is_pd_connected = false;
+		platform_set_vbus_lvl_enable(chip, 0, 0);
+		if (chip->notify.data_role)
+			regmap_update_bits(chip->regmap,
+					   FUSB_REG_SWITCHES1,
+					   SWITCHES1_DATAROLE,
+					   SWITCHES1_DATAROLE);
+		else
+			regmap_update_bits(chip->regmap,
+					   FUSB_REG_SWITCHES1,
+					   SWITCHES1_DATAROLE,
+					   0);
+
+		chip->timer_state = T_SRC_RECOVER;
+		fusb_timer_start(&chip->timer_state_machine,
+				 chip->timer_state);
+		chip->sub_state++;
+		break;
+	default:
+		if (evt & EVENT_TIMER_STATE) {
+			platform_set_vbus_lvl_enable(chip, 1, 0);
+			chip->timer_mux = T_NO_RESPONSE;
+			fusb_timer_start(&chip->timer_mux_machine,
+					 chip->timer_mux);
+			set_state(chip, policy_src_startup);
+			dev_dbg(chip->dev, "reset over-> src startup\n");
+		}
+		break;
+	}
+}
+
+static void fusb_state_vcs_ufp_evaluate_swap(struct fusb30x_chip *chip, u32 evt)
+{
+	if (chip->vconn_supported)
+		set_state(chip, policy_vcs_ufp_accept);
+	else
+		set_state(chip, policy_vcs_ufp_reject);
+}
+
+static void fusb_state_swap_msg_process(struct fusb30x_chip *chip, u32 evt)
+{
+	if (evt & EVENT_RX) {
+		if (PACKET_IS_CONTROL_MSG(chip->rec_head, CMT_PR_SWAP)) {
+			set_state(chip, policy_src_prs_evaluate);
+		} else if (PACKET_IS_CONTROL_MSG(chip->rec_head,
+						 CMT_VCONN_SWAP)) {
+			if (chip->notify.data_role)
+				set_state(chip, chip->conn_state);
+			else
+				set_state(chip, policy_vcs_ufp_evaluate_swap);
+		} else if (PACKET_IS_CONTROL_MSG(chip->rec_head,
+						 CMT_DR_SWAP)) {
+			if (chip->notify.data_role)
+				set_state(chip, policy_drs_dfp_evaluate);
+			else
+				set_state(chip, policy_drs_ufp_evaluate);
+		}
+	}
+}
+
+#define VDM_IS_ACTIVE(chip) \
+	(chip->notify.data_role && chip->vdm_state < VDM_STATE_READY)
+
+static void fusb_state_src_ready(struct fusb30x_chip *chip, u32 evt)
+{
+	if (evt & EVENT_RX) {
+		if (PACKET_IS_DATA_MSG(chip->rec_head, DMT_VENDERDEFINED)) {
+			process_vdm_msg(chip);
+			chip->work_continue |= EVENT_WORK_CONTINUE;
+			chip->timer_state = T_DISABLED;
+		} else if (!VDM_IS_ACTIVE(chip)) {
+			fusb_state_swap_msg_process(chip, evt);
+		}
+	}
+
+	if (!chip->partner_cap[0])
+		set_state(chip, policy_src_get_sink_caps);
+	else if (VDM_IS_ACTIVE(chip))
+		auto_vdm_machine(chip, evt);
+}
+
+static void fusb_state_prs_evaluate(struct fusb30x_chip *chip, u32 evt)
+{
+	if (chip->role == ROLE_MODE_DRP)
+		set_state(chip, policy_src_prs_accept);
+	else
+		set_state(chip, policy_src_prs_reject);
+}
+
+static void fusb_state_send_simple_msg(struct fusb30x_chip *chip, u32 evt,
+				       int cmd, int is_DMT,
+				       enum connection_state state_success,
+				       enum connection_state state_failed)
+{
+	u32 tmp;
+
+	switch (chip->sub_state) {
+	case 0:
+		set_mesg(chip, cmd, is_DMT);
+		chip->tx_state = tx_idle;
+		chip->sub_state++;
+		/* fallthrough */
+	case 1:
+		tmp = policy_send_data(chip);
+		if (tmp == tx_success)
+			set_state(chip, state_success);
+		else if (tmp == tx_failed)
+			set_state(chip, state_failed);
+	}
+}
+
+static void fusb_state_prs_reject(struct fusb30x_chip *chip, u32 evt)
+{
+	fusb_state_send_simple_msg(chip, evt, CMT_REJECT, CONTROLMESSAGE,
+				   (chip->notify.power_role) ?
+				   policy_src_ready : policy_snk_ready,
+				   (chip->notify.power_role) ?
+				   policy_src_send_softrst :
+				   policy_snk_send_softrst);
+}
+
+static void fusb_state_prs_accept(struct fusb30x_chip *chip, u32 evt)
+{
+	fusb_state_send_simple_msg(chip, evt, CMT_ACCEPT, CONTROLMESSAGE,
+				   (chip->notify.power_role) ?
+				   policy_src_prs_transition_to_off :
+				   policy_snk_prs_transition_to_off,
+				   (chip->notify.power_role) ?
+				   policy_src_send_softrst :
+				   policy_snk_send_softrst);
+}
+
+static void fusb_state_vcs_ufp_accept(struct fusb30x_chip *chip, u32 evt)
+{
+	fusb_state_send_simple_msg(chip, evt, CMT_ACCEPT, CONTROLMESSAGE,
+				   (chip->vconn_enabled) ?
+				   policy_vcs_ufp_wait_for_dfp_vconn :
+				   policy_vcs_ufp_turn_on_vconn,
+				   (chip->notify.power_role) ?
+				   policy_src_send_softrst :
+				   policy_snk_send_softrst);
+}
+
+static void fusb_state_vcs_set_vconn(struct fusb30x_chip *chip,
+				     u32 evt, bool on)
+{
+	if (on) {
+		tcpm_set_vconn(chip, 1);
+		set_state(chip, chip->notify.data_role ?
+				policy_vcs_dfp_send_ps_rdy :
+				policy_vcs_ufp_send_ps_rdy);
+	} else {
+		tcpm_set_vconn(chip, 0);
+		if (chip->notify.power_role)
+			set_state(chip, policy_src_ready);
+		else
+			set_state(chip, policy_snk_ready);
+	}
+}
+
+static void fusb_state_vcs_send_ps_rdy(struct fusb30x_chip *chip, u32 evt)
+{
+	fusb_state_send_simple_msg(chip, evt, CMT_PS_RDY, CONTROLMESSAGE,
+				   (chip->notify.power_role) ?
+				   policy_src_ready : policy_snk_ready,
+				   (chip->notify.power_role) ?
+				   policy_src_send_softrst :
+				   policy_snk_send_softrst);
+}
+
+static void fusb_state_vcs_wait_for_vconn(struct fusb30x_chip *chip,
+					  u32 evt)
+{
+	switch (chip->sub_state) {
+	case 0:
+		chip->timer_state = T_PD_VCONN_SRC_ON;
+		fusb_timer_start(&chip->timer_state_machine,
+				 chip->timer_state);
+		chip->sub_state++;
+		/* fallthrough */
+	case 1:
+		if (evt & EVENT_RX) {
+			if (PACKET_IS_CONTROL_MSG(chip->rec_head, CMT_PS_RDY))
+				set_state(chip, chip->notify.data_role ?
+						policy_vcs_dfp_turn_off_vconn :
+						policy_vcs_ufp_turn_off_vconn);
+		} else if (evt & EVENT_TIMER_STATE) {
+			if (chip->notify.power_role)
+				set_state(chip, policy_src_send_hardrst);
+			else
+				set_state(chip, policy_snk_send_hardrst);
+		}
+	}
+}
+
+static void fusb_state_src_prs_transition_to_off(struct fusb30x_chip *chip,
+						 u32 evt)
+{
+	switch (chip->sub_state) {
+	case 0:
+		chip->timer_state = T_SRC_TRANSITION;
+		fusb_timer_start(&chip->timer_state_machine,
+				 chip->timer_state);
+		chip->sub_state++;
+		break;
+	case 1:
+		if (evt & EVENT_TIMER_STATE) {
+			platform_set_vbus_lvl_enable(chip, 0, 0);
+			chip->notify.power_role = POWER_ROLE_SINK;
+			tcpm_set_msg_header(chip);
+			if (chip->role == ROLE_MODE_DRP)
+				set_state(chip, policy_src_prs_assert_rd);
+			else
+				set_state(chip, policy_src_prs_source_off);
+		}
+	}
+}
+
+static void fusb_state_src_prs_assert_rd(struct fusb30x_chip *chip, u32 evt)
+{
+	tcpm_set_cc_pull_mode(chip, CC_PULL_DOWN);
+	set_state(chip, policy_src_prs_source_off);
+}
+
+static void fusb_state_src_prs_source_off(struct fusb30x_chip *chip, u32 evt)
+{
+	u32 tmp;
+
+	switch (chip->sub_state) {
+	case 0:
+		set_mesg(chip, CMT_PS_RDY, CONTROLMESSAGE);
+		chip->tx_state = tx_idle;
+		chip->sub_state++;
+		/* fallthrough */
+	case 1:
+		tmp = policy_send_data(chip);
+		if (tmp == tx_success) {
+			chip->timer_state = T_PD_SOURCE_ON;
+			fusb_timer_start(&chip->timer_state_machine,
+					 chip->timer_state);
+			chip->sub_state++;
+		} else if (tmp == tx_failed) {
+			chip->notify.power_role = POWER_ROLE_SOURCE;
+			tcpm_set_msg_header(chip);
+			set_state(chip, policy_src_send_hardrst);
+		}
+		if (chip->sub_state != 3)
+			break;
+	case 2:
+		if (evt & EVENT_RX) {
+			if (PACKET_IS_CONTROL_MSG(chip->rec_head,
+						  CMT_PS_RDY)) {
+				chip->timer_state = T_DISABLED;
+				/* snk startup */
+				chip->notify.is_pd_connected = false;
+				chip->cc_state |= CC_STATE_TOGSS_IS_UFP;
+				tcpm_set_polarity(chip, chip->cc_polarity);
+				tcpm_set_rx_enable(chip, 1);
+				set_state(chip, policy_snk_discovery);
+			} else {
+				dev_dbg(chip->dev,
+					"rec careless msg: head %x\n",
+					chip->rec_head);
+			}
+		} else if (evt & EVENT_TIMER_STATE) {
+			chip->notify.power_role = POWER_ROLE_SOURCE;
+			tcpm_set_msg_header(chip);
+			set_state(chip, policy_src_send_hardrst);
+		}
+	}
+}
+
+static void fusb_state_drs_evaluate(struct fusb30x_chip *chip, u32 evt)
+{
+	if (chip->pd_cap_info.data_role_swap)
+		/*
+		 * TODO:
+		 * NOW REJECT swap when the port is DFP
+		 * since we should work together with USB part
+		 */
+		set_state(chip, chip->notify.data_role ?
+				policy_drs_dfp_reject : policy_drs_ufp_accept);
+	else
+		set_state(chip, chip->notify.data_role ?
+				policy_drs_dfp_reject : policy_drs_ufp_reject);
+}
+
+static void fusb_state_drs_send_accept(struct fusb30x_chip *chip, u32 evt)
+{
+	fusb_state_send_simple_msg(chip, evt, CMT_ACCEPT, CONTROLMESSAGE,
+				   chip->notify.power_role ?
+				   policy_drs_dfp_change :
+				   policy_drs_ufp_change,
+				   error_recovery);
+}
+
+static void fusb_state_drs_role_change(struct fusb30x_chip *chip, u32 evt)
+{
+	chip->notify.data_role = chip->notify.data_role ?
+				 DATA_ROLE_UFP : DATA_ROLE_DFP;
+	tcpm_set_msg_header(chip);
+	set_state(chip, chip->notify.power_role ? policy_src_ready :
+						  policy_snk_ready);
+}
+
+static void fusb_state_src_get_sink_cap(struct fusb30x_chip *chip, u32 evt)
+{
+	u32 tmp;
+
+	switch (chip->sub_state) {
+	case 0:
+		set_mesg(chip, CMT_GETSINKCAP, CONTROLMESSAGE);
+		chip->tx_state = tx_idle;
+		chip->sub_state++;
+		/* without break */
+	case 1:
+		tmp = policy_send_data(chip);
+		if (tmp == tx_success) {
+			chip->timer_state = T_SENDER_RESPONSE;
+			chip->sub_state++;
+			fusb_timer_start(&chip->timer_state_machine,
+					 chip->timer_state);
+		} else if (tmp == tx_failed) {
+			set_state(chip, policy_src_send_softrst);
+		}
+
+		if (!(evt & FLAG_EVENT))
+			break;
+	default:
+		if (evt & EVENT_RX) {
+			if (PACKET_IS_DATA_MSG(chip->rec_head,
+					       DMT_SINKCAPABILITIES)) {
+				for (tmp = 0;
+				     tmp < PD_HEADER_CNT(chip->rec_head);
+				     tmp++) {
+					chip->partner_cap[tmp] =
+						chip->rec_load[tmp];
+				}
+				set_state(chip, policy_src_ready);
+			} else {
+				chip->partner_cap[0] = 0xffffffff;
+				set_state(chip, policy_src_ready);
+			}
+		} else if (evt & EVENT_TIMER_STATE) {
+			dev_warn(chip->dev, "Get sink cap time out\n");
+			chip->partner_cap[0] = 0xffffffff;
+			set_state(chip, policy_src_ready);
+		}
+	}
+}
 
-	/* Step 1: Set switches so that we measure the right CC pin */
-	switches0_data = (cc_polarity == TYPEC_POLARITY_CC1) ?
-		FUSB_REG_SWITCHES0_CC1_PU_EN | FUSB_REG_SWITCHES0_MEAS_CC1 :
-		FUSB_REG_SWITCHES0_CC2_PU_EN | FUSB_REG_SWITCHES0_MEAS_CC2;
-	ret = fusb302_i2c_write(chip, FUSB_REG_SWITCHES0, switches0_data);
-	if (ret < 0)
-		return ret;
+static void fusb_state_src_send_hardreset(struct fusb30x_chip *chip, u32 evt)
+{
+	u32 tmp;
 
-	fusb302_i2c_read(chip, FUSB_REG_SWITCHES0, &status0);
-	fusb302_log(chip, "get_src_cc_status switches: 0x%0x", status0);
+	switch (chip->sub_state) {
+	case 0:
+		chip->tx_state = tx_idle;
+		chip->sub_state++;
+		/* without break */
+	default:
+		tmp = policy_send_hardrst(chip, evt);
+		if (tmp == tx_success) {
+			chip->hardrst_count++;
+			set_state(chip, policy_src_transition_default);
+		} else if (tmp == tx_failed) {
+			/* can't reach here */
+			set_state(chip, error_recovery);
+		}
+		break;
+	}
+}
 
-	/* Step 2: Set compararator volt to differentiate between Open and Rd */
-	ret = fusb302_i2c_write(chip, FUSB_REG_MEASURE, rd_mda);
-	if (ret < 0)
-		return ret;
+static void fusb_state_src_softreset(struct fusb30x_chip *chip)
+{
+	u32 tmp;
+
+	switch (chip->sub_state) {
+	case 0:
+		set_mesg(chip, CMT_ACCEPT, CONTROLMESSAGE);
+		chip->tx_state = tx_idle;
+		chip->sub_state++;
+		/* without break */
+	default:
+		tmp = policy_send_data(chip);
+		if (tmp == tx_success) {
+			fusb_soft_reset_parameter(chip);
+			set_state(chip, policy_src_send_caps);
+		} else if (tmp == tx_failed) {
+			set_state(chip, policy_src_send_hardrst);
+		}
+		break;
+	}
+}
 
-	usleep_range(50, 100);
-	ret = fusb302_i2c_read(chip, FUSB_REG_STATUS0, &status0);
-	if (ret < 0)
-		return ret;
+static void fusb_state_src_send_softreset(struct fusb30x_chip *chip, u32 evt)
+{
+	u32 tmp;
+
+	switch (chip->sub_state) {
+	case 0:
+		set_mesg(chip, CMT_SOFTRESET, CONTROLMESSAGE);
+		chip->tx_state = tx_idle;
+		chip->sub_state++;
+		/* without break */
+	case 1:
+		tmp = policy_send_data(chip);
+		if (tmp == tx_success) {
+			chip->timer_state = T_SENDER_RESPONSE;
+			chip->sub_state++;
+			fusb_timer_start(&chip->timer_state_machine,
+					 chip->timer_state);
+		} else if (tmp == tx_failed) {
+			set_state(chip, policy_src_send_hardrst);
+		}
 
-	fusb302_log(chip, "get_src_cc_status rd_mda status0: 0x%0x", status0);
-	if (status0 & FUSB_REG_STATUS0_COMP) {
-		*cc = TYPEC_CC_OPEN;
-		return 0;
+		if (!(evt & FLAG_EVENT))
+			break;
+	default:
+		if (evt & EVENT_RX) {
+			if (PACKET_IS_CONTROL_MSG(chip->rec_head, CMT_ACCEPT)) {
+				fusb_soft_reset_parameter(chip);
+				set_state(chip, policy_src_send_caps);
+			}
+		} else if (evt & EVENT_TIMER_STATE) {
+			set_state(chip, policy_src_send_hardrst);
+		}
+		break;
 	}
+}
 
-	/* Step 3: Set compararator input to differentiate between Rd and Ra. */
-	ret = fusb302_i2c_write(chip, FUSB_REG_MEASURE, ra_mda);
-	if (ret < 0)
-		return ret;
+static void fusb_state_snk_startup(struct fusb30x_chip *chip, u32 evt)
+{
+	chip->notify.is_pd_connected = false;
+	fusb_soft_reset_parameter(chip);
 
-	usleep_range(50, 100);
-	ret = fusb302_i2c_read(chip, FUSB_REG_STATUS0, &status0);
-	if (ret < 0)
-		return ret;
+	memset(chip->partner_cap, 0, sizeof(chip->partner_cap));
 
-	fusb302_log(chip, "get_src_cc_status ra_mda status0: 0x%0x", status0);
-	if (status0 & FUSB_REG_STATUS0_COMP)
-		*cc = TYPEC_CC_RD;
-	else
-		*cc = TYPEC_CC_RA;
+	tcpm_set_msg_header(chip);
+	tcpm_set_polarity(chip, chip->cc_polarity);
+	tcpm_set_rx_enable(chip, 1);
+	set_state(chip, policy_snk_discovery);
+	platform_fusb_notify(chip);
+}
 
-	return 0;
+static void fusb_state_snk_discovery(struct fusb30x_chip *chip, u32 evt)
+{
+	set_state(chip, policy_snk_wait_caps);
+	chip->timer_state = T_TYPEC_SINK_WAIT_CAP;
+	fusb_timer_start(&chip->timer_state_machine,
+			 chip->timer_state);
 }
 
-static int fusb302_handle_togdone_src(struct fusb302_chip *chip,
-				      u8 togdone_result)
+static void fusb_state_snk_wait_caps(struct fusb30x_chip *chip, u32 evt)
 {
-	/*
-	 * - set polarity (measure cc, vconn, tx)
-	 * - set pull_up, pull_down
-	 * - set cc1, cc2, and update to tcpm_port
-	 * - set I_COMP interrupt on
-	 */
-	int ret = 0;
-	u8 rd_mda = rd_mda_value[chip->src_current_status];
-	enum toggling_mode toggling_mode = chip->toggling_mode;
-	enum typec_cc_polarity cc_polarity;
-	enum typec_cc_status cc1, cc2;
+	if (evt & EVENT_RX) {
+		if (PACKET_IS_DATA_MSG(chip->rec_head,
+				       DMT_SOURCECAPABILITIES)) {
+			chip->is_pd_support = true;
+			chip->timer_mux = T_DISABLED;
+			set_state(chip, policy_snk_evaluate_caps);
+		}
+	} else if (evt & EVENT_TIMER_STATE) {
+		if (chip->hardrst_count <= N_HARDRESET_COUNT) {
+			if (chip->vbus_begin) {
+				chip->vbus_begin = false;
+				set_state(chip, policy_snk_send_softrst);
+			} else {
+				set_state(chip, policy_snk_send_hardrst);
+			}
+		} else {
+			if (chip->is_pd_support)
+				set_state(chip, error_recovery);
+			else
+				set_state(chip, disabled);
+		}
+	} else if ((evt & EVENT_TIMER_MUX) &&
+		   (chip->hardrst_count > N_HARDRESET_COUNT)) {
+		if (chip->is_pd_support)
+			set_state(chip, error_recovery);
+		else
+			set_state(chip, disabled);
+	}
+}
 
-	/*
-	 * The toggle-engine will stop in a src state if it sees either Ra or
-	 * Rd. Determine the status for both CC pins, starting with the one
-	 * where toggling stopped, as that is where the switches point now.
-	 */
-	if (togdone_result == FUSB_REG_STATUS1A_TOGSS_SRC1)
-		ret = fusb302_get_src_cc_status(chip, TYPEC_POLARITY_CC1, &cc1);
-	else
-		ret = fusb302_get_src_cc_status(chip, TYPEC_POLARITY_CC2, &cc2);
-	if (ret < 0)
-		return ret;
-	/* we must turn off toggling before we can measure the other pin */
-	ret = fusb302_set_toggling(chip, TOGGLING_MODE_OFF);
-	if (ret < 0) {
-		fusb302_log(chip, "cannot set toggling mode off, ret=%d", ret);
-		return ret;
+static void fusb_state_snk_evaluate_caps(struct fusb30x_chip *chip, u32 evt)
+{
+	u32 tmp;
+
+	chip->hardrst_count = 0;
+	chip->pos_power = 0;
+
+	for (tmp = 0; tmp < PD_HEADER_CNT(chip->rec_head); tmp++) {
+		switch (CAP_POWER_TYPE(chip->rec_load[tmp])) {
+		case 0:
+			/* Fixed Supply */
+			if (CAP_FPDO_VOLTAGE(chip->rec_load[tmp]) <= 100)
+				chip->pos_power = tmp + 1;
+			break;
+		case 1:
+			/* Battery */
+			if (CAP_VPDO_VOLTAGE(chip->rec_load[tmp]) <= 100)
+				chip->pos_power = tmp + 1;
+			break;
+		default:
+			/* not meet battery caps */
+			break;
+		}
 	}
-	/* get the status of the other pin */
-	if (togdone_result == FUSB_REG_STATUS1A_TOGSS_SRC1)
-		ret = fusb302_get_src_cc_status(chip, TYPEC_POLARITY_CC2, &cc2);
-	else
-		ret = fusb302_get_src_cc_status(chip, TYPEC_POLARITY_CC1, &cc1);
-	if (ret < 0)
-		return ret;
+	fusb302_set_pos_power_by_charge_ic(chip);
 
-	/* determine polarity based on the status of both pins */
-	if (cc1 == TYPEC_CC_RD &&
-			(cc2 == TYPEC_CC_OPEN || cc2 == TYPEC_CC_RA)) {
-		cc_polarity = TYPEC_POLARITY_CC1;
-	} else if (cc2 == TYPEC_CC_RD &&
-		    (cc1 == TYPEC_CC_OPEN || cc1 == TYPEC_CC_RA)) {
-		cc_polarity = TYPEC_POLARITY_CC2;
+	if ((!chip->pos_power) || (chip->pos_power > 7)) {
+		chip->pos_power = 0;
+		set_state(chip, policy_snk_wait_caps);
 	} else {
-		fusb302_log(chip, "unexpected CC status cc1=%s, cc2=%s, restarting toggling",
-			    typec_cc_status_name[cc1],
-			    typec_cc_status_name[cc2]);
-		return fusb302_set_toggling(chip, toggling_mode);
-	}
-	/* set polarity and pull_up, pull_down */
-	ret = fusb302_set_cc_polarity_and_pull(chip, cc_polarity, true, false);
-	if (ret < 0) {
-		fusb302_log(chip, "cannot set cc polarity %s, ret=%d",
-			    cc_polarity_name[cc_polarity], ret);
-		return ret;
+		set_state(chip, policy_snk_select_cap);
 	}
-	/* update tcpm with the new cc value */
-	if ((chip->cc1 != cc1) || (chip->cc2 != cc2)) {
-		chip->cc1 = cc1;
-		chip->cc2 = cc2;
-		tcpm_cc_change(chip->tcpm_port);
-	}
-	/* set MDAC to Rd threshold, and unmask I_COMP for unplug detection */
-	ret = fusb302_i2c_write(chip, FUSB_REG_MEASURE, rd_mda);
-	if (ret < 0)
-		return ret;
-	/* unmask comp_chng interrupt */
-	ret = fusb302_i2c_clear_bits(chip, FUSB_REG_MASK,
-				     FUSB_REG_MASK_COMP_CHNG);
-	if (ret < 0) {
-		fusb302_log(chip,
-			    "cannot unmask comp_chng interrupt, ret=%d", ret);
-		return ret;
-	}
-	chip->intr_comp_chng = true;
-	fusb302_log(chip, "detected cc1=%s, cc2=%s",
-		    typec_cc_status_name[cc1],
-		    typec_cc_status_name[cc2]);
+}
 
-	return ret;
+static void fusb_state_snk_select_cap(struct fusb30x_chip *chip, u32 evt)
+{
+	u32 tmp;
+
+	switch (chip->sub_state) {
+	case 0:
+		set_mesg(chip, DMT_REQUEST, DATAMESSAGE);
+		chip->sub_state = 1;
+		chip->tx_state = tx_idle;
+		/* without break */
+	case 1:
+		tmp = policy_send_data(chip);
+
+		if (tmp == tx_success) {
+			chip->timer_state = T_SENDER_RESPONSE;
+			fusb_timer_start(&chip->timer_state_machine,
+					 chip->timer_state);
+			chip->sub_state++;
+		} else if (tmp == tx_failed) {
+			set_state(chip, policy_snk_discovery);
+			break;
+		}
+
+		if (!(evt & FLAG_EVENT))
+			break;
+	default:
+		if (evt & EVENT_RX) {
+			if (!PD_HEADER_CNT(chip->rec_head)) {
+				switch (PD_HEADER_TYPE(chip->rec_head)) {
+				case CMT_ACCEPT:
+					set_state(chip,
+						  policy_snk_transition_sink);
+					chip->timer_state = T_PS_TRANSITION;
+					fusb_timer_start(&chip->timer_state_machine,
+							 chip->timer_state);
+					break;
+				case CMT_WAIT:
+				case CMT_REJECT:
+					if (chip->notify.is_pd_connected) {
+						dev_info(chip->dev,
+							 "PD connected as UFP, fetching 5V\n");
+						set_state(chip,
+							  policy_snk_ready);
+					} else {
+						set_state(chip,
+							  policy_snk_wait_caps);
+						/*
+						 * make sure don't send
+						 * hard reset to prevent
+						 * infinite loop
+						 */
+						chip->hardrst_count =
+							N_HARDRESET_COUNT + 1;
+					}
+					break;
+				default:
+					break;
+				}
+			}
+		} else if (evt & EVENT_TIMER_STATE) {
+			set_state(chip, policy_snk_send_hardrst);
+		}
+		break;
+	}
 }
 
-static int fusb302_handle_togdone(struct fusb302_chip *chip)
+static void fusb_state_snk_transition_sink(struct fusb30x_chip *chip, u32 evt)
 {
-	int ret = 0;
-	u8 status1a;
-	u8 togdone_result;
+	if (evt & EVENT_RX) {
+		if (PACKET_IS_CONTROL_MSG(chip->rec_head, CMT_PS_RDY)) {
+			chip->notify.is_pd_connected = true;
+			dev_info(chip->dev,
+				 "PD connected as UFP, fetching 5V\n");
+			set_state(chip, policy_snk_ready);
+		} else if (PACKET_IS_DATA_MSG(chip->rec_head,
+					      DMT_SOURCECAPABILITIES)) {
+			set_state(chip, policy_snk_evaluate_caps);
+		}
+	} else if (evt & EVENT_TIMER_STATE) {
+		set_state(chip, policy_snk_send_hardrst);
+	}
+}
 
-	ret = fusb302_i2c_read(chip, FUSB_REG_STATUS1A, &status1a);
-	if (ret < 0)
-		return ret;
-	togdone_result = (status1a >> FUSB_REG_STATUS1A_TOGSS_POS) &
-			 FUSB_REG_STATUS1A_TOGSS_MASK;
-	switch (togdone_result) {
-	case FUSB_REG_STATUS1A_TOGSS_SNK1:
-	case FUSB_REG_STATUS1A_TOGSS_SNK2:
-		return fusb302_handle_togdone_snk(chip, togdone_result);
-	case FUSB_REG_STATUS1A_TOGSS_SRC1:
-	case FUSB_REG_STATUS1A_TOGSS_SRC2:
-		return fusb302_handle_togdone_src(chip, togdone_result);
-	case FUSB_REG_STATUS1A_TOGSS_AA:
-		/* doesn't support */
-		fusb302_log(chip, "AudioAccessory not supported");
-		fusb302_set_toggling(chip, chip->toggling_mode);
+static void fusb_state_snk_transition_default(struct fusb30x_chip *chip,
+					      u32 evt)
+{
+	switch (chip->sub_state) {
+	case 0:
+		chip->notify.is_pd_connected = false;
+		chip->timer_mux = T_NO_RESPONSE;
+		fusb_timer_start(&chip->timer_mux_machine,
+				 chip->timer_mux);
+		chip->timer_state = T_PS_HARD_RESET_MAX + T_SAFE_0V;
+		fusb_timer_start(&chip->timer_state_machine,
+				 chip->timer_state);
+		if (chip->notify.data_role)
+			tcpm_set_msg_header(chip);
+
+		chip->sub_state++;
+		/* fallthrough */
+	case 1:
+		if (!tcpm_check_vbus(chip)) {
+			chip->sub_state++;
+			chip->timer_state = T_SRC_RECOVER_MAX + T_SRC_TURN_ON;
+			fusb_timer_start(&chip->timer_state_machine,
+					 chip->timer_state);
+		} else if (evt & EVENT_TIMER_STATE) {
+			set_state(chip, policy_snk_startup);
+		}
 		break;
 	default:
-		fusb302_log(chip, "TOGDONE with an invalid state: %d",
-			    togdone_result);
-		fusb302_set_toggling(chip, chip->toggling_mode);
+		if (tcpm_check_vbus(chip)) {
+			chip->timer_state = T_DISABLED;
+			set_state(chip, policy_snk_startup);
+		} else if (evt & EVENT_TIMER_STATE) {
+			set_state(chip, policy_snk_startup);
+		}
 		break;
 	}
-	return ret;
 }
 
-static int fusb302_pd_reset(struct fusb302_chip *chip)
+static void fusb_state_snk_ready(struct fusb30x_chip *chip, u32 evt)
 {
-	return fusb302_i2c_set_bits(chip, FUSB_REG_RESET,
-				    FUSB_REG_RESET_PD_RESET);
+	if (evt & EVENT_RX) {
+		if (PACKET_IS_DATA_MSG(chip->rec_head, DMT_VENDERDEFINED)) {
+			process_vdm_msg(chip);
+			chip->work_continue |= EVENT_WORK_CONTINUE;
+			chip->timer_state = T_DISABLED;
+		} else if (!VDM_IS_ACTIVE(chip)) {
+			fusb_state_swap_msg_process(chip, evt);
+		}
+	}
+
+	if (VDM_IS_ACTIVE(chip))
+		auto_vdm_machine(chip, evt);
+
+	fusb_state_swap_msg_process(chip, evt);
+	platform_fusb_notify(chip);
 }
 
-static int fusb302_pd_read_message(struct fusb302_chip *chip,
-				   struct pd_message *msg)
+static void fusb_state_snk_send_hardreset(struct fusb30x_chip *chip, u32 evt)
 {
-	int ret = 0;
-	u8 token;
-	u8 crc[4];
-	int len;
+	u32 tmp;
 
-	/* first SOP token */
-	ret = fusb302_i2c_read(chip, FUSB_REG_FIFOS, &token);
-	if (ret < 0)
-		return ret;
-	ret = fusb302_i2c_block_read(chip, FUSB_REG_FIFOS, 2,
-				     (u8 *)&msg->header);
-	if (ret < 0)
-		return ret;
-	len = pd_header_cnt_le(msg->header) * 4;
-	/* add 4 to length to include the CRC */
-	if (len > PD_MAX_PAYLOAD * 4) {
-		fusb302_log(chip, "PD message too long %d", len);
-		return -EINVAL;
+	switch (chip->sub_state) {
+	case 0:
+		chip->tx_state = tx_idle;
+		chip->sub_state++;
+	default:
+		tmp = policy_send_hardrst(chip, evt);
+		if (tmp == tx_success) {
+			chip->hardrst_count++;
+			set_state(chip, policy_snk_transition_default);
+		} else if (tmp == tx_failed) {
+			set_state(chip, error_recovery);
+		}
+		break;
 	}
-	if (len > 0) {
-		ret = fusb302_i2c_block_read(chip, FUSB_REG_FIFOS, len,
-					     (u8 *)msg->payload);
-		if (ret < 0)
-			return ret;
+}
+
+static void fusb_state_send_swap(struct fusb30x_chip *chip, u32 evt, int cmd)
+{
+	u32 tmp;
+
+	switch (chip->sub_state) {
+	case 0:
+		set_mesg(chip, cmd, CONTROLMESSAGE);
+		chip->sub_state = 1;
+		chip->tx_state = tx_idle;
+		/* fallthrough */
+	case 1:
+		tmp = policy_send_data(chip);
+
+		if (tmp == tx_success) {
+			chip->timer_state = T_SENDER_RESPONSE;
+			fusb_timer_start(&chip->timer_state_machine,
+					 chip->timer_state);
+			chip->sub_state++;
+		} else if (tmp == tx_failed) {
+			if (cmd == CMT_DR_SWAP) {
+				set_state(chip, error_recovery);
+				return;
+			}
+
+			if (chip->notify.power_role)
+				set_state(chip, policy_src_send_softrst);
+			else
+				set_state(chip, policy_snk_send_softrst);
+		}
+		break;
+	case 2:
+		if (evt & EVENT_RX) {
+			if (PACKET_IS_CONTROL_MSG(chip->rec_head,
+						  CMT_ACCEPT)) {
+				chip->timer_state = T_DISABLED;
+				if (cmd == CMT_VCONN_SWAP) {
+					set_state(chip, chip->vconn_enabled ?
+							policy_vcs_dfp_wait_for_ufp_vconn :
+							policy_vcs_dfp_turn_on_vconn);
+				} else if (cmd == CMT_PR_SWAP) {
+					if (chip->notify.power_role)
+						set_state(chip, policy_src_prs_transition_to_off);
+					else
+						set_state(chip, policy_snk_prs_transition_to_off);
+					chip->notify.power_role = POWER_ROLE_SOURCE;
+					tcpm_set_msg_header(chip);
+				} else if (cmd == CMT_DR_SWAP) {
+					set_state(chip, chip->notify.data_role ?
+							policy_drs_dfp_change :
+							policy_drs_ufp_change);
+				}
+			} else if (PACKET_IS_CONTROL_MSG(chip->rec_head,
+							 CMT_REJECT) ||
+				   PACKET_IS_CONTROL_MSG(chip->rec_head,
+							 CMT_WAIT)) {
+				chip->timer_state = T_DISABLED;
+				if (chip->notify.power_role)
+					set_state(chip, policy_src_ready);
+				else
+					set_state(chip, policy_snk_ready);
+			}
+		} else if (evt & EVENT_TIMER_STATE) {
+			if (chip->notify.power_role)
+				set_state(chip, policy_src_ready);
+			else
+				set_state(chip, policy_snk_ready);
+		}
 	}
-	/* another 4 bytes to read CRC out */
-	ret = fusb302_i2c_block_read(chip, FUSB_REG_FIFOS, 4, crc);
-	if (ret < 0)
-		return ret;
-	fusb302_log(chip, "PD message header: %x", msg->header);
-	fusb302_log(chip, "PD message len: %d", len);
+}
 
-	/*
-	 * Check if we've read off a GoodCRC message. If so then indicate to
-	 * TCPM that the previous transmission has completed. Otherwise we pass
-	 * the received message over to TCPM for processing.
-	 *
-	 * We make this check here instead of basing the reporting decision on
-	 * the IRQ event type, as it's possible for the chip to report the
-	 * TX_SUCCESS and GCRCSENT events out of order on occasion, so we need
-	 * to check the message type to ensure correct reporting to TCPM.
-	 */
-	if ((!len) && (pd_header_type_le(msg->header) == PD_CTRL_GOOD_CRC))
-		tcpm_pd_transmit_complete(chip->tcpm_port, TCPC_TX_SUCCESS);
-	else
-		tcpm_pd_receive(chip->tcpm_port, msg);
+static void fusb_state_snk_prs_transition_to_off(struct fusb30x_chip *chip,
+						 u32 evt)
+{
+	switch (chip->sub_state) {
+	case 0:
+		chip->timer_state = T_PD_SOURCE_OFF;
+		fusb_timer_start(&chip->timer_state_machine,
+				 chip->timer_state);
+		chip->sub_state++;
+		/* fallthrough */
+	case 1:
+		if (evt & EVENT_RX) {
+			if (PACKET_IS_CONTROL_MSG(chip->rec_head,
+						  CMT_PS_RDY)) {
+				if (chip->role == ROLE_MODE_DRP)
+					set_state(chip,
+						  policy_snk_prs_assert_rp);
+				else
+					set_state(chip,
+						  policy_snk_prs_source_on);
+			} else {
+				dev_dbg(chip->dev,
+					"rec careless msg: head %x\n",
+					chip->rec_head);
+			}
+		} else if (evt & EVENT_TIMER_STATE) {
+			chip->notify.power_role = POWER_ROLE_SINK;
+			tcpm_set_msg_header(chip);
+			set_state(chip, policy_snk_send_hardrst);
+		}
+		break;
+	}
+}
 
-	return ret;
+static void fusb_state_snk_prs_assert_rp(struct fusb30x_chip *chip, u32 evt)
+{
+	tcpm_set_cc_pull_mode(chip, CC_PULL_UP);
+	set_state(chip, policy_snk_prs_source_on);
 }
 
-static irqreturn_t fusb302_irq_intn(int irq, void *dev_id)
+static void fusb_state_snk_prs_source_on(struct fusb30x_chip *chip, u32 evt)
 {
-	struct fusb302_chip *chip = dev_id;
-	unsigned long flags;
+	u32 tmp;
+
+	switch (chip->sub_state) {
+	case 0:
+		/* supply power in 50ms */
+		platform_set_vbus_lvl_enable(chip, 1, 0);
+		chip->sub_state++;
+		chip->work_continue |= EVENT_WORK_CONTINUE;
+		break;
+	case 1:
+		set_mesg(chip, CMT_PS_RDY, CONTROLMESSAGE);
+		chip->tx_state = tx_idle;
+		chip->sub_state++;
+		/* fallthrough */
+	case 2:
+		tmp = policy_send_data(chip);
+		if (tmp == tx_success) {
+			/* PD spe 6.5.10.2 */
+			chip->timer_state = T_PD_SWAP_SOURCE_START;
+			fusb_timer_start(&chip->timer_state_machine,
+					 chip->timer_state);
+			chip->sub_state++;
+		} else if (tmp == tx_failed) {
+			chip->notify.power_role = POWER_ROLE_SINK;
+			tcpm_set_msg_header(chip);
+			set_state(chip, policy_snk_send_hardrst);
+		}
+		break;
+	case 3:
+		if (evt & EVENT_TIMER_STATE) {
+			chip->cc_state &= ~CC_STATE_TOGSS_IS_UFP;
+			regmap_update_bits(chip->regmap, FUSB_REG_MASK,
+					   MASK_M_COMP_CHNG, 0);
+			set_state(chip, policy_src_send_caps);
+		}
+		break;
+	}
+}
 
-	/* Disable our level triggered IRQ until our irq_work has cleared it */
-	disable_irq_nosync(chip->gpio_int_n_irq);
+static void fusb_state_snk_softreset(struct fusb30x_chip *chip)
+{
+	u32 tmp;
+
+	switch (chip->sub_state) {
+	case 0:
+		set_mesg(chip, CMT_ACCEPT, CONTROLMESSAGE);
+		chip->tx_state = tx_idle;
+		chip->sub_state++;
+		/* without break */
+	default:
+		tmp = policy_send_data(chip);
+		if (tmp == tx_success) {
+			fusb_soft_reset_parameter(chip);
+			chip->timer_state = T_TYPEC_SINK_WAIT_CAP;
+			fusb_timer_start(&chip->timer_state_machine,
+					 chip->timer_state);
+			set_state(chip, policy_snk_wait_caps);
+		} else if (tmp == tx_failed) {
+			set_state(chip, policy_snk_send_hardrst);
+		}
+		break;
+	}
+}
 
-	spin_lock_irqsave(&chip->irq_lock, flags);
-	if (chip->irq_suspended)
-		chip->irq_while_suspended = true;
-	else
-		schedule_work(&chip->irq_work);
-	spin_unlock_irqrestore(&chip->irq_lock, flags);
+static void fusb_state_snk_send_softreset(struct fusb30x_chip *chip, u32 evt)
+{
+	u32 tmp;
+
+	switch (chip->sub_state) {
+	case 0:
+		set_mesg(chip, CMT_SOFTRESET, CONTROLMESSAGE);
+		chip->tx_state = tx_idle;
+		chip->sub_state++;
+	case 1:
+		tmp = policy_send_data(chip);
+		if (tmp == tx_success) {
+			chip->timer_state = T_SENDER_RESPONSE;
+			chip->sub_state++;
+			fusb_timer_start(&chip->timer_state_machine,
+					 chip->timer_state);
+		} else if (tmp == tx_failed) {
+			/* can't reach here */
+			set_state(chip, policy_snk_send_hardrst);
+		}
 
-	return IRQ_HANDLED;
+		if (!(evt & FLAG_EVENT))
+			break;
+	default:
+		if (evt & EVENT_RX) {
+			if ((!PD_HEADER_CNT(chip->rec_head)) &&
+			    (PD_HEADER_TYPE(chip->rec_head) == CMT_ACCEPT)) {
+				fusb_soft_reset_parameter(chip);
+				chip->timer_state = T_TYPEC_SINK_WAIT_CAP;
+				fusb_timer_start(&chip->timer_state_machine,
+						 chip->timer_state);
+				set_state(chip, policy_snk_wait_caps);
+			}
+		} else if (evt & EVENT_TIMER_STATE) {
+			set_state(chip, policy_snk_send_hardrst);
+		}
+		break;
+	}
 }
 
-static void fusb302_irq_work(struct work_struct *work)
-{
-	struct fusb302_chip *chip = container_of(work, struct fusb302_chip,
-						 irq_work);
-	int ret = 0;
-	u8 interrupt;
-	u8 interrupta;
-	u8 interruptb;
-	u8 status0;
-	bool vbus_present;
-	bool comp_result;
-	bool intr_togdone;
-	bool intr_bc_lvl;
-	bool intr_comp_chng;
-	struct pd_message pd_msg;
-
-	mutex_lock(&chip->lock);
-	/* grab a snapshot of intr flags */
-	intr_togdone = chip->intr_togdone;
-	intr_bc_lvl = chip->intr_bc_lvl;
-	intr_comp_chng = chip->intr_comp_chng;
-
-	ret = fusb302_i2c_read(chip, FUSB_REG_INTERRUPT, &interrupt);
-	if (ret < 0)
-		goto done;
-	ret = fusb302_i2c_read(chip, FUSB_REG_INTERRUPTA, &interrupta);
-	if (ret < 0)
-		goto done;
-	ret = fusb302_i2c_read(chip, FUSB_REG_INTERRUPTB, &interruptb);
-	if (ret < 0)
-		goto done;
-	ret = fusb302_i2c_read(chip, FUSB_REG_STATUS0, &status0);
-	if (ret < 0)
-		goto done;
-	fusb302_log(chip,
-		    "IRQ: 0x%02x, a: 0x%02x, b: 0x%02x, status0: 0x%02x",
-		    interrupt, interrupta, interruptb, status0);
-
-	if (interrupt & FUSB_REG_INTERRUPT_VBUSOK) {
-		vbus_present = !!(status0 & FUSB_REG_STATUS0_VBUSOK);
-		fusb302_log(chip, "IRQ: VBUS_OK, vbus=%s",
-			    vbus_present ? "On" : "Off");
-		if (vbus_present != chip->vbus_present) {
-			chip->vbus_present = vbus_present;
-			tcpm_vbus_change(chip->tcpm_port);
-		}
-	}
-
-	if ((interrupta & FUSB_REG_INTERRUPTA_TOGDONE) && intr_togdone) {
-		fusb302_log(chip, "IRQ: TOGDONE");
-		ret = fusb302_handle_togdone(chip);
-		if (ret < 0) {
-			fusb302_log(chip,
-				    "handle togdone error, ret=%d", ret);
-			goto done;
-		}
-	}
-
-	if ((interrupt & FUSB_REG_INTERRUPT_BC_LVL) && intr_bc_lvl) {
-		fusb302_log(chip, "IRQ: BC_LVL, handler pending");
+static void fusb_try_detach(struct fusb30x_chip *chip)
+{
+	int cc1, cc2;
+
+	if ((chip->cc_state & CC_STATE_TOGSS_IS_UFP) &&
+	    (chip->conn_state !=
+	     policy_snk_transition_default) &&
+	    (chip->conn_state !=
+	     policy_src_prs_source_off) &&
+	    (chip->conn_state != policy_snk_prs_send_swap) &&
+	    (chip->conn_state != policy_snk_prs_assert_rp) &&
+	    (chip->conn_state != policy_snk_prs_source_on) &&
+	    (chip->conn_state != policy_snk_prs_transition_to_off)) {
+		if (!tcpm_check_vbus(chip))
+			set_state_unattached(chip);
+	} else if ((chip->conn_state !=
+		    policy_src_transition_default) &&
+		   (chip->conn_state !=
+		    policy_src_prs_source_off) &&
+		   (chip->conn_state != policy_snk_prs_source_on)) {
+		tcpm_get_cc(chip, &cc1, &cc2);
+		if (chip->cc_state & CC_STATE_TOGSS_CC2)
+			cc1 = cc2;
+		if (cc1 == TYPEC_CC_VOLT_OPEN)
+			set_state_unattached(chip);
+	} else {
 		/*
-		 * as BC_LVL interrupt can be affected by PD activity,
-		 * apply delay to for the handler to wait for the PD
-		 * signaling to finish.
+		 * Detached may occurred at swap operations. So, DON'T ignore
+		 * the EVENT_CC during swapping at all, check the connection
+		 * after it.
 		 */
-		mod_delayed_work(chip->wq, &chip->bc_lvl_handler,
-				 msecs_to_jiffies(T_BC_LVL_DEBOUNCE_DELAY_MS));
+		chip->work_continue |= EVENT_DELAY_CC;
 	}
+}
 
-	if ((interrupt & FUSB_REG_INTERRUPT_COMP_CHNG) && intr_comp_chng) {
-		comp_result = !!(status0 & FUSB_REG_STATUS0_COMP);
-		fusb302_log(chip, "IRQ: COMP_CHNG, comp=%s",
-			    comp_result ? "true" : "false");
-		if (comp_result) {
-			/* cc level > Rd_threshold, detach */
-			chip->cc1 = TYPEC_CC_OPEN;
-			chip->cc2 = TYPEC_CC_OPEN;
-			tcpm_cc_change(chip->tcpm_port);
+static void state_machine_typec(struct fusb30x_chip *chip)
+{
+	u32 evt = 0;
+
+	tcpc_alert(chip, &evt);
+	mux_alert(chip, &evt);
+	if (!evt)
+		goto BACK;
+
+	if (chip->notify.is_cc_connected)
+		if (evt & (EVENT_CC | EVENT_DELAY_CC))
+			fusb_try_detach(chip);
+
+	if (evt & EVENT_RX) {
+		tcpm_get_message(chip);
+		if (PACKET_IS_CONTROL_MSG(chip->rec_head, CMT_SOFTRESET)) {
+			if (chip->notify.power_role)
+				set_state(chip, policy_src_softrst);
+			else
+				set_state(chip, policy_snk_softrst);
 		}
 	}
 
-	if (interrupt & FUSB_REG_INTERRUPT_COLLISION) {
-		fusb302_log(chip, "IRQ: PD collision");
-		tcpm_pd_transmit_complete(chip->tcpm_port, TCPC_TX_FAILED);
+	if (evt & EVENT_TX) {
+		if (chip->tx_state == tx_success)
+			chip->msg_id++;
 	}
+	switch (chip->conn_state) {
+	case disabled:
+		fusb_state_disabled(chip, evt);
+		break;
+	case error_recovery:
+		set_state_unattached(chip);
+		break;
+	case unattached:
+		fusb_state_unattached(chip, evt);
+		break;
+	case attach_wait_sink:
+		fusb_state_attach_wait_sink(chip, evt);
+		break;
+	case attach_wait_source:
+		fusb_state_attach_wait_source(chip, evt);
+		break;
+	case attached_source:
+		fusb_state_attached_source(chip, evt);
+		break;
+	case attached_sink:
+		fusb_state_attached_sink(chip, evt);
+		break;
+	case attach_try_src:
+		fusb_state_try_attach(chip, evt, ROLE_MODE_DFP);
+		break;
+	case attach_try_snk:
+		fusb_state_try_attach(chip, evt, ROLE_MODE_UFP);
+		break;
 
-	if (interrupta & FUSB_REG_INTERRUPTA_RETRYFAIL) {
-		fusb302_log(chip, "IRQ: PD retry failed");
-		tcpm_pd_transmit_complete(chip->tcpm_port, TCPC_TX_FAILED);
-	}
+	/* POWER DELIVERY */
+	case policy_src_startup:
+		fusb_state_src_startup(chip, evt);
+		break;
+	case policy_src_discovery:
+		fusb_state_src_discovery(chip, evt);
+		break;
+	case policy_src_send_caps:
+		fusb_state_src_send_caps(chip, evt);
+		if (chip->conn_state != policy_src_negotiate_cap)
+			break;
+	case policy_src_negotiate_cap:
+		fusb_state_src_negotiate_cap(chip, evt);
+
+	case policy_src_transition_supply:
+		fusb_state_src_transition_supply(chip, evt);
+		break;
+	case policy_src_cap_response:
+		fusb_state_src_cap_response(chip, evt);
+		break;
+	case policy_src_transition_default:
+		fusb_state_src_transition_default(chip, evt);
+		break;
+	case policy_src_ready:
+		fusb_state_src_ready(chip, evt);
+		break;
+	case policy_src_get_sink_caps:
+		fusb_state_src_get_sink_cap(chip, evt);
+		break;
+	case policy_src_send_hardrst:
+		fusb_state_src_send_hardreset(chip, evt);
+		break;
+	case policy_src_send_softrst:
+		fusb_state_src_send_softreset(chip, evt);
+		break;
+	case policy_src_softrst:
+		fusb_state_src_softreset(chip);
+		break;
 
-	if (interrupta & FUSB_REG_INTERRUPTA_HARDSENT) {
-		fusb302_log(chip, "IRQ: PD hardreset sent");
-		ret = fusb302_pd_reset(chip);
-		if (ret < 0) {
-			fusb302_log(chip, "cannot PD reset, ret=%d", ret);
-			goto done;
-		}
-		tcpm_pd_transmit_complete(chip->tcpm_port, TCPC_TX_SUCCESS);
-	}
+	/* UFP */
+	case policy_snk_startup:
+		fusb_state_snk_startup(chip, evt);
+		break;
+	case policy_snk_discovery:
+		fusb_state_snk_discovery(chip, evt);
+		break;
+	case policy_snk_wait_caps:
+		fusb_state_snk_wait_caps(chip, evt);
+		break;
+	case policy_snk_evaluate_caps:
+		fusb_state_snk_evaluate_caps(chip, evt);
+		/* without break */
+	case policy_snk_select_cap:
+		fusb_state_snk_select_cap(chip, evt);
+		break;
+	case policy_snk_transition_sink:
+		fusb_state_snk_transition_sink(chip, evt);
+		break;
+	case policy_snk_transition_default:
+		fusb_state_snk_transition_default(chip, evt);
+		break;
+	case policy_snk_ready:
+		fusb_state_snk_ready(chip, evt);
+		break;
+	case policy_snk_send_hardrst:
+		fusb_state_snk_send_hardreset(chip, evt);
+		break;
+	case policy_snk_send_softrst:
+		fusb_state_snk_send_softreset(chip, evt);
+		break;
+	case policy_snk_softrst:
+		fusb_state_snk_softreset(chip);
+		break;
 
-	if (interrupta & FUSB_REG_INTERRUPTA_TX_SUCCESS) {
-		fusb302_log(chip, "IRQ: PD tx success");
-		ret = fusb302_pd_read_message(chip, &pd_msg);
-		if (ret < 0) {
-			fusb302_log(chip,
-				    "cannot read in PD message, ret=%d", ret);
-			goto done;
-		}
-	}
+	/*
+	 * PD Spec 1.0: PR SWAP: chap 8.3.3.6.3.1/2
+	 *		VC SWAP: chap 8.3.3.7.1/2
+	 */
+	case policy_src_prs_evaluate:
+	case policy_snk_prs_evaluate:
+		fusb_state_prs_evaluate(chip, evt);
+		break;
+	case policy_snk_prs_accept:
+	case policy_src_prs_accept:
+		fusb_state_prs_accept(chip, evt);
+		break;
+	case policy_snk_prs_reject:
+	case policy_src_prs_reject:
+	case policy_vcs_ufp_reject:
+	case policy_drs_dfp_reject:
+	case policy_drs_ufp_reject:
+		fusb_state_prs_reject(chip, evt);
+		break;
+	case policy_src_prs_transition_to_off:
+		fusb_state_src_prs_transition_to_off(chip, evt);
+		break;
+	case policy_src_prs_assert_rd:
+		fusb_state_src_prs_assert_rd(chip, evt);
+		break;
+	case policy_src_prs_source_off:
+		fusb_state_src_prs_source_off(chip, evt);
+		break;
+	case policy_snk_prs_send_swap:
+	case policy_src_prs_send_swap:
+		fusb_state_send_swap(chip, evt, CMT_PR_SWAP);
+		break;
+	case policy_snk_prs_transition_to_off:
+		fusb_state_snk_prs_transition_to_off(chip, evt);
+		break;
+	case policy_snk_prs_assert_rp:
+		fusb_state_snk_prs_assert_rp(chip, evt);
+		break;
+	case policy_snk_prs_source_on:
+		fusb_state_snk_prs_source_on(chip, evt);
+		break;
+	case policy_vcs_ufp_evaluate_swap:
+		fusb_state_vcs_ufp_evaluate_swap(chip, evt);
+		break;
+	case policy_vcs_ufp_accept:
+		fusb_state_vcs_ufp_accept(chip, evt);
+		break;
+	case policy_vcs_ufp_wait_for_dfp_vconn:
+	case policy_vcs_dfp_wait_for_ufp_vconn:
+		fusb_state_vcs_wait_for_vconn(chip, evt);
+		break;
+	case policy_vcs_ufp_turn_off_vconn:
+	case policy_vcs_dfp_turn_off_vconn:
+		fusb_state_vcs_set_vconn(chip, evt, false);
+		break;
+	case policy_vcs_ufp_turn_on_vconn:
+	case policy_vcs_dfp_turn_on_vconn:
+		fusb_state_vcs_set_vconn(chip, evt, true);
+		break;
+	case policy_vcs_ufp_send_ps_rdy:
+	case policy_vcs_dfp_send_ps_rdy:
+		fusb_state_vcs_send_ps_rdy(chip, evt);
+		break;
+	case policy_vcs_dfp_send_swap:
+		fusb_state_send_swap(chip, evt, CMT_VCONN_SWAP);
+		break;
+	case policy_drs_ufp_evaluate:
+	case policy_drs_dfp_evaluate:
+		fusb_state_drs_evaluate(chip, evt);
+		break;
+	case policy_drs_dfp_accept:
+	case policy_drs_ufp_accept:
+		fusb_state_drs_send_accept(chip, evt);
+		break;
+	case policy_drs_dfp_change:
+	case policy_drs_ufp_change:
+		fusb_state_drs_role_change(chip, evt);
+		break;
+	case policy_drs_ufp_send_swap:
+	case policy_drs_dfp_send_swap:
+		fusb_state_send_swap(chip, evt, CMT_DR_SWAP);
+		break;
 
-	if (interrupta & FUSB_REG_INTERRUPTA_HARDRESET) {
-		fusb302_log(chip, "IRQ: PD received hardreset");
-		ret = fusb302_pd_reset(chip);
-		if (ret < 0) {
-			fusb302_log(chip, "cannot PD reset, ret=%d", ret);
-			goto done;
-		}
-		tcpm_pd_hard_reset(chip->tcpm_port);
+	default:
+		break;
 	}
 
-	if (interruptb & FUSB_REG_INTERRUPTB_GCRCSENT) {
-		fusb302_log(chip, "IRQ: PD sent good CRC");
-		ret = fusb302_pd_read_message(chip, &pd_msg);
-		if (ret < 0) {
-			fusb302_log(chip,
-				    "cannot read in PD message, ret=%d", ret);
-			goto done;
-		}
+BACK:
+	if (chip->work_continue) {
+		queue_work(chip->fusb30x_wq, &chip->work);
+		return;
 	}
-done:
-	mutex_unlock(&chip->lock);
-	enable_irq(chip->gpio_int_n_irq);
+
+	if (!platform_get_device_irq_state(chip))
+		fusb_irq_enable(chip);
+	else
+		queue_work(chip->fusb30x_wq, &chip->work);
 }
 
-static int init_gpio(struct fusb302_chip *chip)
+static irqreturn_t cc_interrupt_handler(int irq, void *dev_id)
 {
-	struct device *dev = chip->dev;
-	int ret = 0;
+	struct fusb30x_chip *chip = dev_id;
 
-	chip->gpio_int_n = devm_gpiod_get(dev, "fcs,int_n", GPIOD_IN);
-	if (IS_ERR(chip->gpio_int_n)) {
-		dev_err(dev, "failed to request gpio_int_n\n");
-		return PTR_ERR(chip->gpio_int_n);
-	}
-	ret = gpiod_to_irq(chip->gpio_int_n);
-	if (ret < 0) {
-		dev_err(dev,
-			"cannot request IRQ for GPIO Int_N, ret=%d", ret);
-		return ret;
+	queue_work(chip->fusb30x_wq, &chip->work);
+	fusb_irq_disable(chip);
+	return IRQ_HANDLED;
+}
+
+static int fusb_initialize_gpio(struct fusb30x_chip *chip)
+{
+	chip->gpio_int = devm_gpiod_get_optional(chip->dev, "int-n", GPIOD_IN);
+	if (IS_ERR(chip->gpio_int))
+		return PTR_ERR(chip->gpio_int);
+
+	/* some board support vbus with other ways */
+	chip->gpio_vbus_5v = devm_gpiod_get_optional(chip->dev, "vbus-5v",
+						     GPIOD_OUT_LOW);
+	if (IS_ERR(chip->gpio_vbus_5v))
+		dev_warn(chip->dev,
+			 "Could not get named GPIO for VBus5V!\n");
+	else
+		gpiod_set_value(chip->gpio_vbus_5v, 0);
+
+	chip->gpio_vbus_other = devm_gpiod_get_optional(chip->dev,
+							"vbus-other",
+							GPIOD_OUT_LOW);
+	if (IS_ERR(chip->gpio_vbus_other))
+		dev_warn(chip->dev,
+			 "Could not get named GPIO for VBusOther!\n");
+	else
+		gpiod_set_value(chip->gpio_vbus_other, 0);
+
+	chip->gpio_discharge = devm_gpiod_get_optional(chip->dev, "discharge",
+						       GPIOD_OUT_LOW);
+	if (IS_ERR(chip->gpio_discharge)) {
+		dev_warn(chip->dev,
+			 "Could not get named GPIO for discharge!\n");
+		chip->gpio_discharge = NULL;
 	}
-	chip->gpio_int_n_irq = ret;
+
 	return 0;
 }
 
-#define PDO_FIXED_FLAGS \
-	(PDO_FIXED_DUAL_ROLE | PDO_FIXED_DATA_SWAP | PDO_FIXED_USB_COMM)
+static enum hrtimer_restart fusb_timer_handler(struct hrtimer *timer)
+{
+	int i;
 
-static const u32 src_pdo[] = {
-	PDO_FIXED(5000, 400, PDO_FIXED_FLAGS)
-};
+	for (i = 0; i < fusb30x_port_used; i++) {
+		if (timer == &fusb30x_port_info[i]->timer_state_machine) {
+			if (fusb30x_port_info[i]->timer_state != T_DISABLED)
+				fusb30x_port_info[i]->timer_state = 0;
+			break;
+		}
 
-static const u32 snk_pdo[] = {
-	PDO_FIXED(5000, 400, PDO_FIXED_FLAGS)
-};
+		if (timer == &fusb30x_port_info[i]->timer_mux_machine) {
+			if (fusb30x_port_info[i]->timer_mux != T_DISABLED)
+				fusb30x_port_info[i]->timer_mux = 0;
+			break;
+		}
+	}
 
-static const struct property_entry port_props[] = {
-	PROPERTY_ENTRY_STRING("data-role", "dual"),
-	PROPERTY_ENTRY_STRING("power-role", "dual"),
-	PROPERTY_ENTRY_STRING("try-power-role", "sink"),
-	PROPERTY_ENTRY_U32_ARRAY("source-pdos", src_pdo),
-	PROPERTY_ENTRY_U32_ARRAY("sink-pdos", snk_pdo),
-	PROPERTY_ENTRY_U32("op-sink-microwatt", 2500000),
-	{ }
-};
+	if (i != fusb30x_port_used)
+		queue_work(fusb30x_port_info[i]->fusb30x_wq,
+			   &fusb30x_port_info[i]->work);
+
+	return HRTIMER_NORESTART;
+}
+
+static void fusb_initialize_timer(struct fusb30x_chip *chip)
+{
+	hrtimer_init(&chip->timer_state_machine, CLOCK_MONOTONIC,
+		     HRTIMER_MODE_REL);
+	chip->timer_state_machine.function = fusb_timer_handler;
+
+	hrtimer_init(&chip->timer_mux_machine, CLOCK_MONOTONIC,
+		     HRTIMER_MODE_REL);
+	chip->timer_mux_machine.function = fusb_timer_handler;
+
+	chip->timer_state = T_DISABLED;
+	chip->timer_mux = T_DISABLED;
+}
+
+static void fusb302_work_func(struct work_struct *work)
+{
+	struct fusb30x_chip *chip;
+
+	chip = container_of(work, struct fusb30x_chip, work);
+	//dev_info(&chip->dev, "fusb302_work_func state_machine_typec\n");
+	state_machine_typec(chip);
+}
 
 static struct fwnode_handle *fusb302_fwnode_get(struct device *dev)
 {
-	struct fwnode_handle *fwnode;
+    struct fwnode_handle *fwnode;
 
-	fwnode = device_get_named_child_node(dev, "connector");
-	if (!fwnode)
-		fwnode = fwnode_create_software_node(port_props, NULL);
+    fwnode = device_get_named_child_node(dev, "connector");
+    return fwnode;
+}
 
-	return fwnode;
+static void fusb302_register_dump(struct fusb30x_chip *chip)
+{
+	u8 val;
+	u32 deviceid, switches0, switches1, measure, slice, control0, control1, control2, control3;
+	u32 mask, power, reset, ocpreg, maska, maskb, control4,status0a,status1a,interrupta,interruptb,status0,status1;
+	u32 interrupt,fifo;
+
+	regmap_read(chip->regmap, FUSB_REG_DEVICEID, &deviceid);
+	regmap_read(chip->regmap, FUSB_REG_SWITCHES0, &switches0);
+	regmap_read(chip->regmap, FUSB_REG_SWITCHES1, &switches1);
+	regmap_read(chip->regmap, FUSB_REG_MEASURE, &measure);
+	regmap_read(chip->regmap, FUSB_REG_SLICE, &slice);
+	regmap_read(chip->regmap, FUSB_REG_CONTROL0, &control0);
+	regmap_read(chip->regmap, FUSB_REG_CONTROL1, &control1);
+	regmap_read(chip->regmap, FUSB_REG_CONTROL2, &control2);
+	regmap_read(chip->regmap, FUSB_REG_CONTROL3, &control3);
+	regmap_read(chip->regmap, FUSB_REG_MASK, &mask);
+	regmap_read(chip->regmap, FUSB_REG_POWER, &power);
+	regmap_read(chip->regmap, FUSB_REG_RESET, &reset);
+	regmap_read(chip->regmap, FUSB_REG_OCPREG, &ocpreg);
+	regmap_read(chip->regmap, FUSB_REG_MASKA, &maska);
+	regmap_read(chip->regmap, FUSB_REG_MASKB, &maskb);
+	regmap_read(chip->regmap, FUSB_REG_CONTROL4, &control4);
+	regmap_read(chip->regmap, FUSB_REG_STATUS0A, &status0a);
+	regmap_read(chip->regmap, FUSB_REG_STATUS1A, &status1a);
+	regmap_read(chip->regmap, FUSB_REG_INTERRUPTA, &interrupta);
+	regmap_read(chip->regmap, FUSB_REG_INTERRUPTB, &interruptb);
+	regmap_read(chip->regmap, FUSB_REG_STATUS0, &status0);
+	regmap_read(chip->regmap, FUSB_REG_STATUS1, &status1);
+	regmap_read(chip->regmap, FUSB_REG_INTERRUPT, &interrupt);
+	regmap_read(chip->regmap, FUSB_REG_FIFO, &fifo);
+
+	dev_info(chip->dev, "fusb30x_probe deviceid : 0x%x\n", deviceid);
+	dev_info(chip->dev, "fusb30x_probe switches0 : 0x%x\n", switches0);
+	dev_info(chip->dev, "fusb30x_probe switches1 : 0x%x\n", switches1);
+	dev_info(chip->dev, "fusb30x_probe measure : 0x%x\n", measure);
+	dev_info(chip->dev, "fusb30x_probe slice : 0x%x\n", slice);
+	dev_info(chip->dev, "fusb30x_probe control0 : 0x%x\n", control0);
+	dev_info(chip->dev, "fusb30x_probe control1 : 0x%x\n", control1);
+	dev_info(chip->dev, "fusb30x_probe control2 : 0x%x\n", control2);
+	dev_info(chip->dev, "fusb30x_probe control3 : 0x%x\n", control3);
+	dev_info(chip->dev, "fusb30x_probe mask : 0x%x\n", mask);
+	dev_info(chip->dev, "fusb30x_probe power : 0x%x\n", power);
+	dev_info(chip->dev, "fusb30x_probe reset : 0x%x\n", reset);
+	dev_info(chip->dev, "fusb30x_probe ocpreg : 0x%x\n", ocpreg);
+	dev_info(chip->dev, "fusb30x_probe maska : 0x%x\n", maska);
+	dev_info(chip->dev, "fusb30x_probe maskb : 0x%x\n", maskb);
+	dev_info(chip->dev, "fusb30x_probe control4 : 0x%x\n", control4);
+	dev_info(chip->dev, "fusb30x_probe status0a : 0x%x\n", status0a);
+	dev_info(chip->dev, "fusb30x_probe status1a : 0x%x\n", status1a);
+	dev_info(chip->dev, "fusb30x_probe interrupta : 0x%x\n", interrupta);
+	dev_info(chip->dev, "fusb30x_probe interruptb : 0x%x\n", interruptb);
+	dev_info(chip->dev, "fusb30x_probe status0 : 0x%x\n", status0);
+	dev_info(chip->dev, "fusb30x_probe status1 : 0x%x\n", status1);
+	dev_info(chip->dev, "fusb30x_probe interrupt : 0x%x\n", interrupt);
+	dev_info(chip->dev, "fusb30x_probe fifo : 0x%x\n", fifo);
 }
 
-static int fusb302_probe(struct i2c_client *client,
+static int fusb30x_probe(struct i2c_client *client,
 			 const struct i2c_device_id *id)
 {
-	struct fusb302_chip *chip;
-	struct i2c_adapter *adapter = client->adapter;
-	struct device *dev = &client->dev;
-	const char *name;
-	int ret = 0;
+	struct fusb30x_chip *chip;
+	struct PD_CAP_INFO *pd_cap_info;
+	int ret;
+	char *string[2];
 
-	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_I2C_BLOCK)) {
-		dev_err(&client->dev,
-			"I2C/SMBus block functionality not supported!\n");
-		return -ENODEV;
-	}
+	dev_info(&client->dev, "fusb30x_probe start\n");
 	chip = devm_kzalloc(&client->dev, sizeof(*chip), GFP_KERNEL);
 	if (!chip)
 		return -ENOMEM;
 
-	chip->i2c_client = client;
-	chip->dev = &client->dev;
-	mutex_init(&chip->lock);
+	dev_info(&client->dev, "fusb30x_probe fusb30x_port_used :%d\n", fusb30x_port_used);
+	if (fusb30x_port_used == 0xff)
+		return -1;
 
-	/*
-	 * Devicetree platforms should get extcon via phandle (not yet
-	 * supported). On ACPI platforms, we get the name from a device prop.
-	 * This device prop is for kernel internal use only and is expected
-	 * to be set by the platform code which also registers the i2c client
-	 * for the fusb302.
-	 */
-	if (device_property_read_string(dev, "linux,extcon-name", &name) == 0) {
-		chip->extcon = extcon_get_extcon_dev(name);
-		if (!chip->extcon)
-			return -EPROBE_DEFER;
+	chip->port_num = fusb30x_port_used++;
+	fusb30x_port_info[chip->port_num] = chip;
+
+	chip->dev = &client->dev;
+	chip->regmap = devm_regmap_init_i2c(client, &fusb302_regmap_config);
+	if (IS_ERR(chip->regmap)) {
+		dev_err(&client->dev, "Failed to allocate regmap!\n");
+		return PTR_ERR(chip->regmap);
 	}
 
-	chip->vbus = devm_regulator_get(chip->dev, "vbus");
-	if (IS_ERR(chip->vbus))
-		return PTR_ERR(chip->vbus);
+	ret = fusb_initialize_gpio(chip);
+	if (ret){
+		dev_err(&client->dev, "fusb_initialize_gpio Failed\n");
+		return ret;
+	}
 
-	chip->wq = create_singlethread_workqueue(dev_name(chip->dev));
-	if (!chip->wq)
-		return -ENOMEM;
+	fusb_initialize_timer(chip);
 
-	spin_lock_init(&chip->irq_lock);
-	INIT_WORK(&chip->irq_work, fusb302_irq_work);
-	INIT_DELAYED_WORK(&chip->bc_lvl_handler, fusb302_bc_lvl_handler_work);
-	init_tcpc_dev(&chip->tcpc_dev);
-	fusb302_debugfs_init(chip);
+	chip->fusb30x_wq = create_workqueue("fusb302_wq");
+	INIT_WORK(&chip->work, fusb302_work_func);
 
-	if (client->irq) {
-		chip->gpio_int_n_irq = client->irq;
-	} else {
-		ret = init_gpio(chip);
-		if (ret < 0)
-			goto destroy_workqueue;
+	chip->role = ROLE_MODE_NONE;
+	chip->try_role = ROLE_MODE_NONE;
+	if (!of_property_read_string(chip->dev->of_node, "fusb302,role",
+				     (const char **)&string[0])) {
+		if (!strcmp(string[0], "ROLE_MODE_DRP"))
+			chip->role = ROLE_MODE_DRP;
+		else if (!strcmp(string[0], "ROLE_MODE_DFP"))
+			chip->role = ROLE_MODE_DFP;
+		else if (!strcmp(string[0], "ROLE_MODE_UFP"))
+			chip->role = ROLE_MODE_UFP;
 	}
 
-	chip->tcpc_dev.fwnode = fusb302_fwnode_get(dev);
-	if (IS_ERR(chip->tcpc_dev.fwnode)) {
-		ret = PTR_ERR(chip->tcpc_dev.fwnode);
-		goto destroy_workqueue;
+	if (chip->role == ROLE_MODE_NONE) {
+		dev_warn(chip->dev,
+			 "Can't get property of role, set role to default DRP\n");
+		chip->role = ROLE_MODE_DRP;
+		string[0] = "ROLE_MODE_DRP";
+	}
+
+	if (!of_property_read_string(chip->dev->of_node, "fusb302,try_role",
+				     (const char **)&string[1])) {
+		if (!strcmp(string[1], "ROLE_MODE_DFP"))
+			chip->try_role = ROLE_MODE_DFP;
+		else if (!strcmp(string[1], "ROLE_MODE_UFP"))
+			chip->try_role = ROLE_MODE_UFP;
+	}
+
+	if (chip->try_role == ROLE_MODE_NONE)
+		string[1] = "ROLE_MODE_NONE";
+
+	chip->vconn_supported = true;
+	tcpm_init(chip);
+	tcpm_set_rx_enable(chip, 0);
+	chip->conn_state = unattached;
+	tcpm_set_cc(chip, chip->role);
+
+	chip->n_caps_used = 1;
+	chip->source_power_supply[0] = 0x64;
+	chip->source_max_current[0] = 0x96;
+
+	pd_cap_info = &chip->pd_cap_info;
+	pd_cap_info->dual_role_power = 1;
+	pd_cap_info->data_role_swap = 1;
+
+	pd_cap_info->externally_powered = 1;
+	pd_cap_info->usb_suspend_support = 0;
+	pd_cap_info->usb_communications_cap = 0;
+	pd_cap_info->supply_type = 0;
+	pd_cap_info->peak_current = 0;
+
+    
+	chip->fwnode_connector = fusb302_fwnode_get(&client->dev);
+	if (IS_ERR(chip->fwnode_connector)) {
+		ret = PTR_ERR(chip->fwnode_connector);
+		dev_err(&client->dev,
+		"failed to get connector node %d\n", ret);
+		return ret;
 	}
 
-	chip->tcpm_port = tcpm_register_port(&client->dev, &chip->tcpc_dev);
-	if (IS_ERR(chip->tcpm_port)) {
-		fwnode_handle_put(chip->tcpc_dev.fwnode);
-		ret = PTR_ERR(chip->tcpm_port);
-		if (ret != -EPROBE_DEFER)
-			dev_err(dev, "cannot register tcpm port, ret=%d", ret);
-		goto destroy_workqueue;
+	chip->role_sw = fwnode_usb_role_switch_get(chip->fwnode_connector);
+	if (IS_ERR(chip->role_sw)) {
+		ret = PTR_ERR(chip->role_sw);
+		dev_err(&client->dev,
+		"failed to get fwnode_usb_role_switch_gete %d\n", ret);
+		return ret;
 	}
 
-	ret = request_irq(chip->gpio_int_n_irq, fusb302_irq_intn,
-			  IRQF_ONESHOT | IRQF_TRIGGER_LOW,
-			  "fsc_interrupt_int_n", chip);
-	if (ret < 0) {
-		dev_err(dev, "cannot request IRQ for GPIO Int_N, ret=%d", ret);
-		goto tcpm_unregister_port;
-	}
-	enable_irq_wake(chip->gpio_int_n_irq);
 	i2c_set_clientdata(client, chip);
 
-	return ret;
+	spin_lock_init(&chip->irq_lock);
+	chip->enable_irq = 1;
 
-tcpm_unregister_port:
-	tcpm_unregister_port(chip->tcpm_port);
-	fwnode_handle_put(chip->tcpc_dev.fwnode);
-destroy_workqueue:
-	fusb302_debugfs_exit(chip);
-	destroy_workqueue(chip->wq);
+	chip->gpio_int_irq = gpiod_to_irq(chip->gpio_int);
+	if (chip->gpio_int_irq < 0) {
+		dev_err(&client->dev,
+			"Unable to request IRQ for INT_N GPIO! %d\n",
+			ret);
+		ret = chip->gpio_int_irq;
+		goto IRQ_ERR;
+	}
+
+	ret = devm_request_threaded_irq(&client->dev,
+					chip->gpio_int_irq,
+					NULL,
+					cc_interrupt_handler,
+					IRQF_ONESHOT | IRQF_TRIGGER_LOW,
+					client->name,
+					chip);
+	if (ret) {
+		dev_err(&client->dev, "irq request failed\n");
+		goto IRQ_ERR;
+	}
+	// fusb302_register_dump(chip);
+
+	dev_info(chip->dev,
+		 "port %d probe success with role %s, try_role %s\n",
+		 chip->port_num, string[0], string[1]);
+	return 0;
 
+IRQ_ERR:
+	dev_err(&client->dev, "fusb30x_probe IRQ_ERR\n");
+	destroy_workqueue(chip->fusb30x_wq);
 	return ret;
 }
 
-static int fusb302_remove(struct i2c_client *client)
-{
-	struct fusb302_chip *chip = i2c_get_clientdata(client);
-
-	disable_irq_wake(chip->gpio_int_n_irq);
-	free_irq(chip->gpio_int_n_irq, chip);
-	cancel_work_sync(&chip->irq_work);
-	cancel_delayed_work_sync(&chip->bc_lvl_handler);
-	tcpm_unregister_port(chip->tcpm_port);
-	fwnode_handle_put(chip->tcpc_dev.fwnode);
-	destroy_workqueue(chip->wq);
-	fusb302_debugfs_exit(chip);
-
-	return 0;
-}
-
-static int fusb302_pm_suspend(struct device *dev)
+static int fusb30x_remove(struct i2c_client *client)
 {
-	struct fusb302_chip *chip = dev->driver_data;
-	unsigned long flags;
-
-	spin_lock_irqsave(&chip->irq_lock, flags);
-	chip->irq_suspended = true;
-	spin_unlock_irqrestore(&chip->irq_lock, flags);
+	struct fusb30x_chip *chip = i2c_get_clientdata(client);
 
-	/* Make sure any pending irq_work is finished before the bus suspends */
-	flush_work(&chip->irq_work);
+	destroy_workqueue(chip->fusb30x_wq);
 	return 0;
 }
 
-static int fusb302_pm_resume(struct device *dev)
+static void fusb30x_shutdown(struct i2c_client *client)
 {
-	struct fusb302_chip *chip = dev->driver_data;
-	unsigned long flags;
+	struct fusb30x_chip *chip = i2c_get_clientdata(client);
 
-	spin_lock_irqsave(&chip->irq_lock, flags);
-	if (chip->irq_while_suspended) {
-		schedule_work(&chip->irq_work);
-		chip->irq_while_suspended = false;
+	if (chip->gpio_vbus_5v)
+		gpiod_set_value(chip->gpio_vbus_5v, 0);
+	if (chip->gpio_discharge) {
+		gpiod_set_value(chip->gpio_discharge, 1);
+		msleep(100);
+		gpiod_set_value(chip->gpio_discharge, 0);
 	}
-	chip->irq_suspended = false;
-	spin_unlock_irqrestore(&chip->irq_lock, flags);
-
-	return 0;
 }
 
-static const struct of_device_id fusb302_dt_match[] = {
-	{.compatible = "fcs,fusb302"},
+static const struct of_device_id fusb30x_dt_match[] = {
+	{ .compatible = FUSB30X_I2C_DEVICETREE_NAME },
 	{},
 };
-MODULE_DEVICE_TABLE(of, fusb302_dt_match);
+MODULE_DEVICE_TABLE(of, fusb30x_dt_match);
 
-static const struct i2c_device_id fusb302_i2c_device_id[] = {
-	{"typec_fusb302", 0},
-	{},
-};
-MODULE_DEVICE_TABLE(i2c, fusb302_i2c_device_id);
-
-static const struct dev_pm_ops fusb302_pm_ops = {
-	.suspend = fusb302_pm_suspend,
-	.resume = fusb302_pm_resume,
+static const struct i2c_device_id fusb30x_i2c_device_id[] = {
+	{ FUSB30X_I2C_DRIVER_NAME, 0 },
+	{}
 };
+MODULE_DEVICE_TABLE(i2c, fusb30x_i2c_device_id);
 
-static struct i2c_driver fusb302_driver = {
+static struct i2c_driver fusb30x_driver = {
 	.driver = {
-		   .name = "typec_fusb302",
-		   .pm = &fusb302_pm_ops,
-		   .of_match_table = of_match_ptr(fusb302_dt_match),
-		   },
-	.probe = fusb302_probe,
-	.remove = fusb302_remove,
-	.id_table = fusb302_i2c_device_id,
+		.name = FUSB30X_I2C_DRIVER_NAME,
+		.of_match_table = of_match_ptr(fusb30x_dt_match),
+	},
+	.probe = fusb30x_probe,
+	.remove = fusb30x_remove,
+	.shutdown = fusb30x_shutdown,
+	.id_table = fusb30x_i2c_device_id,
 };
-module_i2c_driver(fusb302_driver);
 
-MODULE_AUTHOR("Yueyao Zhu <yueyao.zhu@gmail.com>");
-MODULE_DESCRIPTION("Fairchild FUSB302 Type-C Chip Driver");
+module_i2c_driver(fusb30x_driver);
+
 MODULE_LICENSE("GPL");
+MODULE_AUTHOR("zain wang <zain.wang@rock-chips.com>");
+MODULE_DESCRIPTION("fusb302 typec pd driver");
diff --git a/drivers/usb/typec/tcpm/fusb302.h b/drivers/usb/typec/tcpm/fusb302.h
new file mode 100644
index 000000000..f957ca546
--- /dev/null
+++ b/drivers/usb/typec/tcpm/fusb302.h
@@ -0,0 +1,554 @@
+/*
+ * Copyright (c) 2016, Fuzhou Rockchip Electronics Co., Ltd
+ * Author: Zain Wang <zain.wang@rock-chips.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * Some ideas are from chrome ec and fairchild GPL fusb302 driver.
+ */
+
+#ifndef FUSB302_H
+#define FUSB302_H
+
+#include <linux/i2c.h>
+#include <linux/hrtimer.h>
+
+const char *FUSB_DT_INTERRUPT_INTN =	"fsc_interrupt_int_n";
+#define FUSB_DT_GPIO_INTN		"fairchild,int_n"
+#define FUSB_DT_GPIO_VBUS_5V		"fairchild,vbus5v"
+#define FUSB_DT_GPIO_VBUS_OTHER		"fairchild,vbusOther"
+
+#define FUSB30X_I2C_DRIVER_NAME		"fusb302"
+#define FUSB30X_I2C_DEVICETREE_NAME	"fairchild,fusb302"
+
+/* FUSB300 Register Addresses */
+#define FUSB_REG_DEVICEID		0x01
+#define FUSB_REG_SWITCHES0		0x02
+#define FUSB_REG_SWITCHES1		0x03
+#define FUSB_REG_MEASURE		0x04
+#define FUSB_REG_SLICE			0x05
+#define FUSB_REG_CONTROL0		0x06
+#define FUSB_REG_CONTROL1		0x07
+#define FUSB_REG_CONTROL2		0x08
+#define FUSB_REG_CONTROL3		0x09
+#define FUSB_REG_MASK			0x0A
+#define FUSB_REG_POWER			0x0B
+#define FUSB_REG_RESET			0x0C
+#define FUSB_REG_OCPREG			0x0D
+#define FUSB_REG_MASKA			0x0E
+#define FUSB_REG_MASKB			0x0F
+#define FUSB_REG_CONTROL4		0x10
+#define FUSB_REG_STATUS0A		0x3C
+#define FUSB_REG_STATUS1A		0x3D
+#define FUSB_REG_INTERRUPTA		0x3E
+#define FUSB_REG_INTERRUPTB		0x3F
+#define FUSB_REG_STATUS0		0x40
+#define FUSB_REG_STATUS1		0x41
+#define FUSB_REG_INTERRUPT		0x42
+#define FUSB_REG_FIFO			0x43
+
+enum connection_state {
+	disabled = 0,
+	error_recovery,
+	unattached,
+	attach_wait_sink,
+	attach_wait_source,
+	attached_source,
+	attached_sink,
+
+	policy_src_startup,
+	policy_src_send_caps,
+	policy_src_discovery,
+	policy_src_negotiate_cap,
+	policy_src_cap_response,
+	policy_src_transition_supply,
+	policy_src_transition_default,
+
+	policy_src_ready,
+	policy_src_get_sink_caps,
+
+	policy_src_send_softrst,
+	policy_src_softrst,
+	policy_src_send_hardrst,
+
+	policy_snk_startup,
+	policy_snk_discovery,
+	policy_snk_wait_caps,
+	policy_snk_evaluate_caps,
+	policy_snk_select_cap,
+	policy_snk_transition_sink,
+	policy_snk_ready,
+
+	policy_snk_send_softrst,
+	policy_snk_softrst,
+	policy_snk_send_hardrst,
+
+	policy_snk_transition_default,
+
+	/* PR SWAP */
+	policy_src_prs_evaluate,
+	policy_src_prs_accept,
+	policy_src_prs_transition_to_off,
+	policy_src_prs_source_off,
+	policy_src_prs_assert_rd,
+	policy_src_prs_reject,
+	policy_src_prs_send_swap,
+
+	policy_snk_prs_evaluate,
+	policy_snk_prs_accept,
+	policy_snk_prs_transition_to_off,
+	policy_snk_prs_source_on,
+	policy_snk_prs_assert_rp,
+	policy_snk_prs_reject,
+	policy_snk_prs_send_swap,
+
+	/* VC SWAP */
+	policy_vcs_dfp_send_swap,
+	policy_vcs_dfp_wait_for_ufp_vconn,
+	policy_vcs_dfp_turn_off_vconn,
+	policy_vcs_dfp_turn_on_vconn,
+	policy_vcs_dfp_send_ps_rdy,
+
+	policy_vcs_ufp_evaluate_swap,
+	policy_vcs_ufp_reject,
+	policy_vcs_ufp_accept,
+	policy_vcs_ufp_wait_for_dfp_vconn,
+	policy_vcs_ufp_turn_off_vconn,
+	policy_vcs_ufp_turn_on_vconn,
+	policy_vcs_ufp_send_ps_rdy,
+
+	policy_drs_ufp_evaluate,
+	policy_drs_ufp_accept,
+	policy_drs_ufp_reject,
+	policy_drs_ufp_change,
+	policy_drs_ufp_send_swap,
+
+	policy_drs_dfp_evaluate,
+	policy_drs_dfp_accept,
+	policy_drs_dfp_reject,
+	policy_drs_dfp_change,
+	policy_drs_dfp_send_swap,
+
+	attach_try_src,
+	attach_try_snk,
+};
+
+enum vdm_state {
+	VDM_STATE_DISCOVERY_ID,
+	VDM_STATE_DISCOVERY_SVID,
+	VDM_STATE_DISCOVERY_MODES,
+	VDM_STATE_ENTER_MODE,
+	VDM_STATE_UPDATE_STATUS,
+	VDM_STATE_DP_CONFIG,
+	VDM_STATE_NOTIFY,
+	VDM_STATE_READY,
+	VDM_STATE_ERR,
+};
+
+enum tcpm_rp_value {
+	TYPEC_RP_USB = 0,
+	TYPEC_RP_1A5 = 1,
+	TYPEC_RP_3A0 = 2,
+	TYPEC_RP_RESERVED = 3,
+};
+
+enum role_mode {
+	ROLE_MODE_NONE,
+	ROLE_MODE_DRP,
+	ROLE_MODE_UFP,
+	ROLE_MODE_DFP,
+	ROLE_MODE_ASS,
+};
+
+#define SBF(s, v)		((s) << (v))
+#define SWITCHES0_PDWN1		SBF(1, 0)
+#define SWITCHES0_PDWN2		SBF(1, 1)
+#define SWITCHES0_MEAS_CC1	SBF(1, 2)
+#define SWITCHES0_MEAS_CC2	SBF(1, 3)
+#define SWITCHES0_VCONN_CC1	SBF(1, 4)
+#define SWITCHES0_VCONN_CC2	SBF(1, 5)
+#define SWITCHES0_PU_EN1	SBF(1, 6)
+#define SWITCHES0_PU_EN2	SBF(1, 7)
+
+#define SWITCHES1_TXCC1		SBF(1, 0)
+#define SWITCHES1_TXCC2		SBF(1, 1)
+#define SWITCHES1_AUTO_CRC	SBF(1, 2)
+#define SWITCHES1_DATAROLE	SBF(1, 4)
+#define SWITCHES1_SPECREV	SBF(3, 5)
+#define SWITCHES1_POWERROLE	SBF(1, 7)
+
+#define MEASURE_MDAC		SBF(0x3f, 0)
+#define MEASURE_VBUS		SBF(1, 6)
+
+#define SLICE_SDAC		SBF(0x3f, 0)
+#define SLICE_SDAC_HYS		SBF(3, 6)
+
+#define CONTROL0_TX_START	SBF(1, 0)
+#define CONTROL0_AUTO_PRE	SBF(1, 1)
+#define CONTROL0_HOST_CUR	SBF(3, 2)
+#define CONTROL0_HOST_CUR_USB		SBF(1, 2)
+#define CONTROL0_HOST_CUR_1A5		SBF(2, 2)
+#define CONTROL0_HOST_CUR_3A0		SBF(3, 2)
+#define CONTROL0_INT_MASK	SBF(1, 5)
+#define CONTROL0_TX_FLUSH	SBF(1, 6)
+
+#define CONTROL1_ENSOP1		SBF(1, 0)
+#define CONTROL1_ENSOP2		SBF(1, 1)
+#define CONTROL1_RX_FLUSH	SBF(1, 2)
+#define CONTROL1_BIST_MODE2	SBF(1, 4)
+#define CONTROL1_ENSOP1DB	SBF(1, 5)
+#define CONTROL1_ENSOP2DB	SBF(1, 6)
+
+#define CONTROL2_TOGGLE		SBF(1, 0)
+#define CONTROL2_MODE		SBF(3, 1)
+#define CONTROL2_MODE_NONE	0
+#define CONTROL2_MODE_DFP	SBF(3, 1)
+#define CONTROL2_MODE_UFP	SBF(2, 1)
+#define CONTROL2_MODE_DRP	SBF(1, 1)
+#define CONTROL2_WAKE_EN	SBF(1, 3)
+#define CONTROL2_TOG_RD_ONLY	SBF(1, 5)
+#define CONTROL2_TOG_SAVE_PWR1	SBF(1, 6)
+#define CONTROL2_TOG_SAVE_PWR2	SBF(1, 7)
+
+#define CONTROL3_AUTO_RETRY	SBF(1, 0)
+#define CONTROL3_N_RETRIES	SBF(3, 1)
+#define CONTROL3_AUTO_SOFTRESET	SBF(1, 3)
+#define CONTROL3_AUTO_HARDRESET	SBF(1, 4)
+#define CONTROL3_SEND_HARDRESET	SBF(1, 6)
+
+#define MASK_M_BC_LVL		SBF(1, 0)
+#define MASK_M_COLLISION	SBF(1, 1)
+#define MASK_M_WAKE		SBF(1, 2)
+#define MASK_M_ALERT		SBF(1, 3)
+#define MASK_M_CRC_CHK		SBF(1, 4)
+#define MASK_M_COMP_CHNG	SBF(1, 5)
+#define MASK_M_ACTIVITY		SBF(1, 6)
+#define MASK_M_VBUSOK		SBF(1, 7)
+
+#define POWER_PWR		SBF(0xf, 0)
+
+#define RESET_SW_RESET		SBF(1, 0)
+#define RESET_PD_RESET		SBF(1, 1)
+
+#define MASKA_M_HARDRST		SBF(1, 0)
+#define MASKA_M_SOFTRST		SBF(1, 1)
+#define MASKA_M_TXSENT		SBF(1, 2)
+#define MASKA_M_HARDSENT	SBF(1, 3)
+#define MASKA_M_RETRYFAIL	SBF(1, 4)
+#define MASKA_M_SOFTFAIL	SBF(1, 5)
+#define MASKA_M_TOGDONE		SBF(1, 6)
+#define MASKA_M_OCP_TEMP	SBF(1, 7)
+
+#define MASKB_M_GCRCSEND	SBF(1, 0)
+
+#define CONTROL4_TOG_USRC_EXIT	SBF(1, 0)
+
+#define MDAC_1P6V		0x26
+
+#define STATUS0A_HARDRST	SBF(1, 0)
+#define STATUS0A_SOFTRST	SBF(1, 1)
+#define STATUS0A_POWER23	SBF(3, 2)
+#define STATUS0A_RETRYFAIL	SBF(1, 4)
+#define STATUS0A_SOFTFAIL	SBF(1, 5)
+#define STATUS0A_TOGDONE	SBF(1, 6)
+#define STATUS0A_M_OCP_TEMP	SBF(1, 7)
+
+#define STATUS1A_RXSOP		SBF(1, 0)
+#define STATUS1A_RXSOP1DB	SBF(1, 1)
+#define STATUS1A_RXSOP2DB	SBF(1, 2)
+#define STATUS1A_TOGSS		SBF(7, 3)
+#define CC_STATE_TOGSS_CC1	SBF(1, 0)
+#define CC_STATE_TOGSS_CC2	SBF(1, 1)
+#define CC_STATE_TOGSS_IS_UFP	SBF(1, 2)
+
+#define INTERRUPTA_HARDRST	SBF(1, 0)
+#define INTERRUPTA_SOFTRST	SBF(1, 1)
+#define INTERRUPTA_TXSENT	SBF(1, 2)
+#define INTERRUPTA_HARDSENT	SBF(1, 3)
+#define INTERRUPTA_RETRYFAIL	SBF(1, 4)
+#define INTERRUPTA_SOFTFAIL	SBF(1, 5)
+#define INTERRUPTA_TOGDONE	SBF(1, 6)
+#define INTERRUPTA_OCP_TEMP	SBF(1, 7)
+
+#define INTERRUPTB_GCRCSENT	SBF(1, 0)
+
+#define STATUS0_BC_LVL		SBF(3, 0)
+#define STATUS0_WAKE		SBF(1, 2)
+#define STATUS0_ALERT		SBF(1, 3)
+#define STATUS0_CRC_CHK		SBF(1, 4)
+#define STATUS0_COMP		SBF(1, 5)
+#define STATUS0_ACTIVITY	SBF(1, 6)
+#define STATUS0_VBUSOK		SBF(1, 7)
+
+#define STATUS1_OCP		SBF(1, 0)
+#define STATUS1_OVRTEMP		SBF(1, 1)
+#define STATUS1_TX_FULL		SBF(1, 2)
+#define STATUS1_TX_EMPTY	SBF(1, 3)
+#define STATUS1_RX_FULL		SBF(1, 4)
+#define STATUS1_RX_EMPTY	SBF(1, 5)
+#define STATUS1_RXSOP1		SBF(1, 6)
+#define STATUS1_RXSOP2		SBF(1, 7)
+
+#define INTERRUPT_BC_LVL	SBF(1, 0)
+#define INTERRUPT_COLLISION	SBF(1, 1)
+#define INTERRUPT_WAKE		SBF(1, 2)
+#define INTERRUPT_ALERT		SBF(1, 3)
+#define INTERRUPT_CRC_CHK	SBF(1, 4)
+#define INTERRUPT_COMP_CHNG	SBF(1, 5)
+#define INTERRUPT_ACTIVITY	SBF(1, 6)
+#define INTERRUPT_VBUSOK	SBF(1, 7)
+
+#define FUSB_TKN_TXON		0xa1
+#define FUSB_TKN_SYNC1		0x12
+#define FUSB_TKN_SYNC2		0x13
+#define FUSB_TKN_SYNC3		0x1b
+#define FUSB_TKN_RST1		0x15
+#define FUSB_TKN_RST2		0x16
+#define FUSB_TKN_PACKSYM	0x80
+#define FUSB_TKN_JAMCRC		0xff
+#define FUSB_TKN_EOP		0x14
+#define FUSB_TKN_TXOFF		0xfe
+
+/* USB PD Control Message Types */
+#define CONTROLMESSAGE		0
+#define CMT_GOODCRC		1
+#define CMT_GOTOMIN		2
+#define CMT_ACCEPT		3
+#define CMT_REJECT		4
+#define CMT_PING		5
+#define CMT_PS_RDY		6
+#define CMT_GETSOURCECAP	7
+#define CMT_GETSINKCAP		8
+#define CMT_DR_SWAP		9
+#define CMT_PR_SWAP		10
+#define CMT_VCONN_SWAP		11
+#define CMT_WAIT		12
+#define CMT_SOFTRESET		13
+
+/* USB PD Data Message Types */
+#define DATAMESSAGE		1
+#define DMT_SOURCECAPABILITIES	1
+#define DMT_REQUEST		2
+#define DMT_BIST		3
+#define DMT_SINKCAPABILITIES	4
+#define DMT_VENDERDEFINED	15
+
+/* VDM Command Types */
+#define VDM_DISCOVERY_ID	0X01
+#define VDM_DISCOVERY_SVIDS	0X02
+#define VDM_DISCOVERY_MODES	0X03
+#define VDM_ENTER_MODE		0X04
+#define VDM_EXIT_MODE		0X05
+#define VDM_ATTENTION		0X06
+#define VDM_DP_STATUS_UPDATE	0X10
+#define VDM_DP_CONFIG		0X11
+
+#define VDM_TYPE_INIT		0
+#define VDM_TYPE_ACK		1
+#define VDM_TYPE_NACK		2
+#define VDM_TYPE_BUSY		3
+
+/* 200ms at least, 1 cycle about 6ms */
+#define N_DEBOUNCE_CNT		33
+#define N_CAPS_COUNT		50
+#define N_HARDRESET_COUNT	0
+
+#define T_NO_RESPONSE		5000
+#define T_SRC_RECOVER		830
+#define T_TYPEC_SEND_SOURCECAP	100
+#define T_SENDER_RESPONSE	30
+#define T_SRC_TRANSITION	30
+#define T_TYPEC_SINK_WAIT_CAP	500
+#define T_PS_TRANSITION		500
+#define T_BMC_TIMEOUT		5
+#define T_PS_HARD_RESET_MAX	35
+#define T_SAFE_0V		650
+#define T_SRC_TURN_ON		275
+#define T_SRC_RECOVER_MAX	1000
+#define T_PD_SOURCE_OFF		920
+#define T_PD_SOURCE_ON		480
+#define T_PD_SWAP_SOURCE_START	20
+#define T_PD_VCONN_SRC_ON	100
+#define T_PD_TRY_DRP		75
+
+#define T_NO_TRIGGER		500
+#define T_DISABLED		0xffff
+
+#define PD_HEADER_CNT(header)		(((header) >> 12) & 7)
+#define PD_HEADER_TYPE(header)		((header) & 0xF)
+#define PD_HEADER_ID(header)		(((header) >> 9) & 7)
+
+#define VDM_HEADER_TYPE(header)		(((header) >> 6) & 3)
+#define VDMHEAD_CMD_TYPE_MASK		(3 << 6)
+#define VDMHEAD_CMD_MASK		(0x1f << 0)
+#define VDMHEAD_STRUCT_TYPE_MASK	BIT(15)
+
+#define GET_VDMHEAD_CMD_TYPE(head)	((head & VDMHEAD_CMD_TYPE_MASK) >> 6)
+#define GET_VDMHEAD_CMD(head)		(head & VDMHEAD_CMD_MASK)
+#define GET_VDMHEAD_STRUCT_TYPE(head)	((head & VDMHEAD_STRUCT_TYPE_MASK) >> 15)
+
+#define DP_STATUS_MASK			0x000000ff
+#define DP_STATUS_HPD_STATE		BIT(7)
+
+#define GET_DP_STATUS(status)		(status & DP_STATUS_MASK)
+#define GET_DP_STATUS_HPD(status)	((status & DP_STATUS_HPD_STATE) >> 7)
+
+#define VDM_IDHEAD_USBVID_MASK		(0xffff << 0)
+#define VDM_IDHEAD_MODALSUPPORT_MASK	BIT(26)
+#define VDM_IDHEAD_PRODUCTTYPE		(7 << 27)
+#define VDM_IDHEAD_USBDEVICE		BIT(30)
+#define VDM_IDHEAD_USBHOST		BIT(30)
+
+#define CAP_POWER_TYPE(PDO)		((PDO >> 30) & 3)
+#define CAP_FPDO_VOLTAGE(PDO)		((PDO >> 10) & 0x3ff)
+#define CAP_VPDO_VOLTAGE(PDO)		((PDO >> 20) & 0x3ff)
+#define CAP_FPDO_CURRENT(PDO)		((PDO >> 0) & 0x3ff)
+#define CAP_VPDO_CURRENT(PDO)		((PDO >> 0) & 0x3ff)
+
+enum CC_ORIENTATION {
+	NONE,
+	CC1,
+	CC2,
+};
+
+enum typec_cc_polarity {
+	TYPEC_POLARITY_CC1,
+	TYPEC_POLARITY_CC2,
+};
+
+enum CC_MODE {
+	CC_PULL_UP,
+	CC_PULL_DOWN,
+	CC_PULL_NONE,
+};
+
+enum typec_power_role {
+	POWER_ROLE_SINK = 0,
+	POWER_ROLE_SOURCE,
+};
+
+enum typec_data_role {
+	DATA_ROLE_UFP = 0,
+	DATA_ROLE_DFP,
+};
+
+struct notify_info {
+	enum CC_ORIENTATION orientation;
+	/* 0 UFP : 1 DFP */
+	enum typec_power_role power_role;
+	enum typec_data_role data_role;
+
+	bool is_cc_connected;
+	bool is_pd_connected;
+
+	bool is_enter_mode;
+	int pin_assignment_support;
+	int pin_assignment_def;
+	bool attention;
+	u32 dp_status;
+	u32 dp_caps;
+};
+
+enum tx_state {
+	tx_idle,
+	tx_busy,
+	tx_failed,
+	tx_success
+};
+
+struct PD_CAP_INFO {
+	u32 peak_current;
+	u32 specification_revision;
+	u32 externally_powered;
+	u32 usb_suspend_support;
+	u32 usb_communications_cap;
+	u32 dual_role_power;
+	u32 data_role_swap;
+	u32 supply_type;
+};
+
+struct fusb30x_chip {
+	struct i2c_client *client;
+	struct device *dev;
+	struct regmap *regmap;
+	struct work_struct work;
+	struct workqueue_struct *fusb30x_wq;
+	struct hrtimer timer_state_machine;
+	struct hrtimer timer_mux_machine;
+	struct PD_CAP_INFO pd_cap_info;
+	struct notify_info notify;
+	struct notify_info notify_cmp;
+	struct extcon_dev *extcon;
+    struct fwnode_handle *fwnode_connector;
+    struct usb_role_switch *role_sw;
+	enum connection_state conn_state;
+	struct gpio_desc *gpio_vbus_5v;
+	struct gpio_desc *gpio_vbus_other;
+	struct gpio_desc *gpio_int;
+	struct gpio_desc *gpio_discharge;
+	int timer_state;
+	int timer_mux;
+	int port_num;
+	u32 work_continue;
+	spinlock_t irq_lock;
+	int gpio_int_irq;
+	int enable_irq;
+
+	/*
+	 * ---------------------------------
+	 * | role 0x03 << 2, | cc_use 0x03 |
+	 * | src  1 << 2,    | cc1 1       |
+	 * | snk  2 << 2,    | cc2 2       |
+	 * ---------------------------------
+	 */
+	u8 cc_state;
+	int cc1;
+	int cc2;
+	enum typec_cc_polarity cc_polarity;
+	u8 val_tmp;
+	u8 debounce_cnt;
+	int sub_state;
+	int caps_counter;
+	u32 send_load[7];
+	u32 rec_load[7];
+	u16 send_head;
+	u16 rec_head;
+	int msg_id;
+	enum tx_state tx_state;
+	int hardrst_count;
+	u32 source_power_supply[7];
+	/* 50mv unit */
+	u32 source_max_current[7];
+	/* 10ma uint*/
+	int pos_power;
+	/*
+	 * if PartnerCap[0] == 0xffffffff
+	 * show Partner Device do not support supply
+	 */
+	u32 partner_cap[7];
+	int n_caps_used;
+	int vdm_state;
+	int vdm_substate;
+	int vdm_send_state;
+	u16 vdm_svid[12];
+	int vdm_svid_num;
+	u32 vdm_id;
+	u8 chip_id;
+	bool vconn_enabled;
+	bool is_pd_support;
+	int pd_output_vol;
+	int pd_output_cur;
+	int cc_meas_high;
+	int cc_meas_low;
+	bool vbus_begin;
+
+	enum role_mode role;
+	bool vconn_supported;
+	bool try_role_complete;
+	enum role_mode try_role;
+};
+
+#endif /* FUSB302_H */
+
